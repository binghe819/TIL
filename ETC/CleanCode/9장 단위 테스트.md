> [클린 코드](http://www.yes24.com/Product/Goods/11681152?OzSrank=1)를 정리한 자료입니다.

# 9장 단위 테스트

- [9장 단위 테스트](#9장-단위-테스트)
  - [TDD 법칙 세 가지](#tdd-법칙-세-가지)
  - [테스트 코드도 깨끗해야 한다](#테스트-코드도-깨끗해야-한다)
    - [테스트 코드는 막 짜면 안된다](#테스트-코드는-막-짜면-안된다)
    - [테스트는 유연성, 유지보수성, 재사용성을 제공한다](#테스트는-유연성-유지보수성-재사용성을-제공한다)
  - [깨끗한 테스트 코드](#깨끗한-테스트-코드)
    - [Build-Operator-Check](#build-operator-check)
    - [도메인 특화된 언어 사용](#도메인-특화된-언어-사용)
    - [이중 표준](#이중-표준)
  - [테스트 당 assert 하나](#테스트-당-assert-하나)
    - [assert 문 개수는 최대한 줄여야 좋다](#assert-문-개수는-최대한-줄여야-좋다)
    - [테스트 함수 하나는 개념 하나만 테스트하라](#테스트-함수-하나는-개념-하나만-테스트하라)
  - [FIRST](#first)

<br>

## TDD 법칙 세 가지
**TDD의 기본원칙은 실제 코드를 짜기 전에 단위 테스트부터 짜는 것이다.**

이외에도 세 가지의 법칙이 있다.

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

이렇게 실제 코드와 테스트 코드를 묶어서 개발해야 한다.

 <br>

 ## 테스트 코드도 깨끗해야 한다

<br>

### 테스트 코드는 막 짜면 안된다
* 안 좋은 예시 - '지저분해도 빨리'
  * 그저 돌아만 가고, 일회성으로 실제 코드를 테스트하는 코드는 굉장히 나쁘다.
* 테스트 코드를 막 짜면 안되는 이유
  * **실제 코드가 진화할수록 테스트 코드도 변화해야한다.**
    * 테스트 코드가 지저분할수록 변경하기 어려워지며, 실제 코드보다 테스트 코드를 작성하는데 많은 시간을 허비하게 된다.
  * 새 버전을 출시할 때마다 테스트 케이스를 유지보수하는 비용이 늘어난다.
  * 결국, 테스트 작성을 비난하게 되고 악순환이 된다.
* **테스트 코드는 실제 코드 못지 않게 중요하다.**
  * 테스트 코드는 이류 시민이 아니다.
  * 실제 코드 못지 않게 깨끗하게 짜야 한다.
  * **테스트 코드를 깨끗하게 유지하자.**

 <br>

 ### 테스트는 유연성, 유지보수성, 재사용성을 제공한다
코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 **단위 테스트**이다.

**테스트 케이스가 있으면 변경이 두렵지 않다.** 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 실제로 테스트 커버리지가 높을수록 공포는 줄어든다.

그러므로 **실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 깨끗하게 보존하는 열쇠다.**

따라서 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다. **테스트 코드가 지저분할수록 실제 코드도 지저분해진다.** 

<br>

## 깨끗한 테스트 코드
깨끗한 테스트 코드를 만들려면 **가독성**이 필요하다.

테스트 코드도 실제 코드와 똑같이 최소의 표현으로 많은 것을 나타내야한다. (명료성, 단순성, 풍부한 표현력)

<br>

### Build-Operator-Check
단위 테스트를 작성하는데 사용되는 패턴이다.

각 테스트는 명확히 세 부분으로 나뉜다.

1. 테스트 자료를 만든다.
2. 테스트 자료를 조작한다.
3. 조작한 결과가 올바른지 확인한다.

> given, when, then과 비슷하다.

<br>

### 도메인 특화된 언어 사용
* Domain Specific Language
  * 특정한 도메인(산업, 분야 등 특정 영역)에서 발생하는 문제점을 해결하는 것에 중점을 두고 도메인을 기준으로 모든 것을 풀어나가기 위해서 제공되는 언어
  * 특정 영역의 해결에는 그 영역에 맞는 특화된 도구를 사용하자는 의미
* 테스트 API를 구현해 도메인 특화 언어를 만들면 테스트 코드를 짜기가 쉬워진다.
  * **흔히 쓰는 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현하여 테스트하라는 의미.**
  * **이렇게 구현한 함수와 유틸리티는 테스트 코드에서 사용하는 특수 API가 된다. (테스트 언어)**

<br>

### 이중 표준
테스트 코드는 표현력이 풍부해야 하지만, 실제 코드 만큼 효율적일 필요는 없다

예를 들어, `StringBuffer`를 사용하지 않고, String 연산은 해도 된다.

테스트 환경에선 리소스 문제가 발생할 확률이 낮기 때문이다.

<br>

## 테스트 당 assert 하나

<br>

### assert 문 개수는 최대한 줄여야 좋다
* 테스트 당 assert 하나는 좋지만 시간이 많이 필요하다.
  * assert문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.
  * 하지만, 그러기위해서는 함수를 많이 분리해야하고, 중복된 코드를 제거하기위해서 여러 디자인 패턴등을 사용하게 된다. (템플릿 메서드 패턴)
  * 배보다 배꼽이 더 크다.
* 그럼에도 assert 문 개수는 최대한 줄여야 좋다.
  * 가독성이나 유지보수면에서 최대한 줄이는 것이 좋다.

<br>

### 테스트 함수 하나는 개념 하나만 테스트하라
* **테스트당 assert는 힘들다. 그보다 '테스트 함수마다 한 개념만 테스트'가 더 합리적이다.**

<br>

## FIRST
깨끗한 테스트는 다음 다섯 가지 규칙을 따른다.
* Fast : 테스트는 빨라야 한다. 
  * 느리면 자주 돌릴 엄두를 못 낸다.
* Independent : 각 테스트는 독립적이어야한다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다. 
  * 테스트가 서로 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워진다.
* Repeatable : 테스트는 어떤 환경에서도 반복 가능해야 한다.
  * 실제 환경, QA 환경등 모든 환경에서 실행할 수 있어야 한다.
* Self-Validating : 테스트는 불리언값으로 결과를 내야 한다. (성공 / 실패)
  * 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다.
* Timely : 테스트는 적시에 작성해야 한다.
  * 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.