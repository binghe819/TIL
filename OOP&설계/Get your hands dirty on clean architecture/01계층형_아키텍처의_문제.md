이 문서는 [Get your hands dirty on clean architecture](https://www.amazon.com/Hands-Dirty-Clean-Architecture-hands/dp/1839211962)의 번역본인 [만들면서 배우는 클린 아키텍처](http://www.yes24.com/product/goods/105138479)를 필자의 관점에서 정리한 문서입니다.

<br>

# 목차

<br>

- [목차](#목차)
- [계층형 아키텍처의 문제는 무엇일까?](#계층형-아키텍처의-문제는-무엇일까)
  - [1 전통적인 계층형 아키텍처](#1-전통적인-계층형-아키텍처)
  - [2 전통적인 계층형 아키텍처의 문제점](#2-전통적인-계층형-아키텍처의-문제점)
  - [3 계층형도 규칙을 명확히하면 유용하다.](#3-계층형도-규칙을-명확히하면-유용하다)

<br>

# 계층형 아키텍처의 문제는 무엇일까?
이번 챕터에선 저자가 전통적인 계층형 아키텍처를 사용하면서 느꼈던 단점에 대해서 이야기한다.

❗️ **이번 챕터의 내용은 모두 Bad Practice이다!**

<br>

## 1 전통적인 계층형 아키텍처

<br>

🤔 **전통적인 계층형 아키텍처란?**

<p align="center"><img src="./image/IMG_4F27CB47CFB2-1.jpeg" width="400"><br>상위 수준 관점에서 일반적인 3계층 아키텍처를 그린 그림<br>출처: Get your hands dirty on clean architecture</p>

* 웹 계층: 웹 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다.
* 도메인 / 비즈니스 계층: 서비스 계층은 필요한 도메인을 이용하여 비즈니스 로직을 수행한다. 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출한다.
* 영속성 계층: 도메인 엔티티의 상태를 DB에 영속화하는 역할을 수행하는 계층.

> 위 구조를 Spring에서 흔히 사용하는 계층 구조로 보면 아래와 같다.
> * 웹 계층 => Controller, 도메인 / 비즈니스 계층 => Service, Domain, 영속성 계층 => DAO

<br>

💁‍♂️ 전통적인 계층형 아키텍처의 장점

* 잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있다.
  * 물론 이는 모든 구성원이 계층을 잘 이해하고 정해진 규칙을 잘 지킨다는 가정하이다.

<br>

## 2 전통적인 계층형 아키텍처의 문제점
계층형 아키텍처는 코드에 나쁜 습관들이 스며들기 쉽게 만들고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만들어 많은 허점을 노출한다.

다시말해, 정해진 규칙을 모두 정말 잘 지켜야지만 효과적인 아키텍처이다.

문제는 이러한 규칙을 잘 지키기가 쉽지 않다는 것.


<br>

1️⃣ **계층형 아키텍처는 DB 주도 설계를 유도한다.**

* **모든 것이 영속성 계층을 토대로 만들어진다**
  * 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기에 자연스레 DB에 의존하게 된다.
* **모든 애플리케이션의 목적은 비즈니스 로직을 처리하는 것이다.**
  * 비즈니스 로직을 처리하기 위해선 상태(state)가 아닌 행동(behavior)에 집중해야 한다. (객체지향)
  * **문제는 계층형 아키텍처는 DB주도 설계를 유도하기에 상태에 더 집중하게된다.**
  * 이는 계층형 아키텍처의 조건상 자연스러운 구현순서이다. 하지만 비즈니스 관점에서는 전혀 맞지 않다.
  * **무엇보다 비즈니스 로직을 처리하는 도메인을 가장 먼저 고려하고 만들어야한다.** (도메인 로직 구현 -> 웹, 영속성 계층 구현)
* **DB주도 설계를 하는 이유?**
  * **가장 큰 원인은 ORM 프레임워크를 사용하기 때문이다.** (혹은 DAO로 엔티티와 테이블을 1 : 1 매칭시키기 때문)
  * **서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 즉시로딩/지연로딩, 트랜잭션, 엔티티매니저등 영속성 계층과 관련된 작업들을 해야한다.**
  * 영속성 코드가 사실상 도메인 코드에 녹아들어가게된다. 이는 서비스 계층이 영속성 계층에 종속적이게 만들고, **영속성 계층과 도메인 계층 사이에 강한 결합을 만든다.**

<p align="center"><img src="./image/IMG_BAA505507118-1.jpeg" width="400"><br>도메인 계층에서 DB 엔티티를 사용하는 것은 영속성 계층과의 강한 결합을 유발한다.<br>출처: Get your hands dirty on clean architecture </p>

> 개인적으로 도메인을 먼저 고려한다면 DB 주도가 아닌 도메인 주도 개발을 할 수 있다고 생각한다. 하지만 이런 경우에도 JPA로 인해 서비스 계층과 영속성 계층의 결합을 분리하긴 어렵다.

<br>

2️⃣ **지름길을 택하기 쉬워진다.**

* 계층형 아키텍처의 유일한 규칙은 `특정 계층에선 같은 계층에 있는 컴포넌트가 아래 계층 컴포넌트만 접근 가능`이다.
  * 그러므로 만약 상위 계층에 위치한 컴포넌트에 접근해야한다면 컴포넌트를 아래로 내려야한다.
* 만약 상위 계층에 위치한 컴포넌트에 접근해야한다면 상위 계층 컴포넌트를 아래로 내려 쉽게 해결가능하다.
  * **문제는 이렇게 컴포넌트를 계속해서 아래로 내린다면, 아래 계층으로 갈수록 점점 비대해진다.**
  * **이는 아래와 같이 아무 계층에도 속하지 않는 컴포넌트를 모두 아래 계층으로 내릴 가능성이 크다.**
  
<p align="center"><img src="./image/IMG_9B2769C5801A-1.jpeg" width="400"><br>영속성 계층에서 모든 것에 접근 가능하기 때문에 시간이 지나면서 점점 비대해진다.<br>출처: Get your hands dirty on clean architecture</p>

<br>

3️⃣ **테스트하기 어려워진다.**

<p align="center"><img src="./image/IMG_51AA79BC1AC7-1.jpeg" width="400"><br>도메인 계층을 건너뛰는 것은 도메인 로직을 코드 여기저기에 흩어지게 만든다.<br>출처: Get your hands dirty on clean architecture </p>

* 계층형 아키텍처를 사용할 때 흔히 계층을 건너뛰는 유혹을 받는다.
  * 예를 들어, 도메인의 상태만을 변경한다면 웹 계층에서 바로 영속성 계층에 접근하는 경우.
* **계층을 건너뛰는 경우 아래와 같은 문제가 발생한다.**
  1. 계층을 건너뛰다보면 도메인에 대한 처리가 다른 계층에 가므로 **각 계층간의 역할과 책임이 불분명해진다.**
  2. 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 경우도 모킹해줘야한다.

<br>

4️⃣ **변경해야하는 로직을 찾기 어려워진다.**

* 앞서 말했듯이, **계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.**
  * **이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일이 점점 어려워진다.** -> 유스케이스를 숨기는 결과가 발생한다.
* 또한, **아래와 같이 점점 Fat Service가 되므로, 추가된 요구사항에 맞는 유스케이스를 찾기가 점점 어려워진다.**

<p align="center"><img src="./image/IMG_4F27CB47CFB2-3.png" width="400"><br>넓은 서비스는 코드 상에서 특정 유스케이스를 찾기 어렵다.<br>출처: Get your hands dirty on clean architecture </p>

<br>

## 3 계층형도 규칙을 명확히하면 유용하다.

계층형 아키텍처의 규칙과 팀에서 정한 규칙을 잘 준수한다면 계층형 아키텍처도 유지보수와 확장면에서 유용할 수 있다.

필자의 경우 실제 진행한 프로젝트([Github Repo 기반 개발 장려 SNS](https://github.com/woowacourse-teams/2021-pick-git))에서 DDD 계층 구조를 사용했으며, 팀원들과 몇 가지 추가 규칙를 통해 유지보수와 확장면에서 만족스러운 설계였다.

<p align="center"><img src="./image/1_F82KYklUqew6ycZEq9niAw.png" width="400"><br>출처: Domain-Driven Design </p>

위 구조를 이용하며 Domain에는 인터페이스를 두고, Infrastructure에 구현체를 둠으로써 DIP를 잘 활용하여 확장에 유연한 설계를 만들 수 있었다.

**위와 같이 일정 규모의 서비스를 만들 때 계층형 규칙도 분명 좋은 아키텍처이다. 다만 이러한 규칙을 팀원 모두가 지킬려면 큰 노력이 필요하다.**

