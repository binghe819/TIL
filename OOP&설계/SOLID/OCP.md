# 목차

- [목차](#목차)
- [OCP - 개방 폐쇄 원칙](#ocp---개방-폐쇄-원칙)
  - [개념](#개념)
  - [아키텍처 수준의 OCP 예시](#아키텍처-수준의-ocp-예시)
  - [쉬운 예제 1](#쉬운-예제-1)
  - [쉬운 예제 2](#쉬운-예제-2)
  - [쉬운 예제 3](#쉬운-예제-3)
  - [쉬운 예제 4](#쉬운-예제-4)
- [생각해볼 점](#생각해볼-점)
- [참고](#참고)

<br>

# OCP - 개방 폐쇄 원칙

> * "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다." - 로버트 C. 마틴
> * "만족스러운 모듈화를 위한 최소한의 조건은 개방성과 폐쇄성을 모두 갖춘 모듈을 만드는 것이다." - 로버트 C. 마틴
> * "자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다."

<br>

## 개념

* 확장에는 열려 있고, 변경에는 닫혀 있다는 원칙
  * ***기존의 코드를 변경하지 않고(Closed), 기능을 수정하거나 추가할 수 있도록(Open)해야 한다.***
  * 인터페이스의 코드는 변경하지 않고, 인터페이스에 정의된 기능을 구현하는 구현체는 추가할 수 있도록 하는 원칙 
* **사실 OCP은 런타임 의존성과 컴파일타임 의존성에 관한 이야기이다**
  * **핵심은 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라**
  * `if-else`를 통한 컴파일 의존성이 아니다!
* 추상화와 전략 패턴
  * OCP는 추상화가 핵심이다. (구현을 숨기고, 확장하는 것)
  * 추상화만 했다고 OCP가 아니다. 변하는 것이 무엇인지 이해해야 한다.
    * **변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야한다.**
  * **변하는 것(핵심 로직)과 변하지 않는 것(부가 로직)을 분리해야 한다.**
* **다형성과 인터페이스를 통해 변하는 부분과 변하지 않는 부분을 분리**
* **시스템을 변경하지 않고도 시스템의 행위를 확장할 수 있다.**
* **목표**
  * **시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.**
  * **컴포넌트 단위로 불리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 계층구조를 만드는 것이 목적이다. - 가장 중요!!**
* 특징
  * 방향성 제어 (DIP와도 관계가 깊다.)
  * 정보 은닉

<br>

## 아키텍처 수준의 OCP 예시

재무재표를 웹 페이지로 보여주는 시스템이 있다고 가정해본다.

책에선 SRP와 DIP를 사용하여 최대한 코드의 변경이 줄이는 방식으로 아키텍처를 설계했다.

(일반적인 MVC 패턴과 비슷하다.)

<p align="center"><img src="./image/ocp_architecture_example.png" width="500"><br>출처: 클린 아키텍처 </p>

위와 같이 컴포넌트를 분리시켰다.

**중요한 점은 계층구조가 '레벨'이라는 개념을 바탕으로 돌아간다.**

**저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다. - 가장 중요한 내용!**

쉽게 얘기해서, View (가장 낮은 수준)에서의 변경은 Interactor (가장 높은 수준)에 영향을 주지 못한다.

**이것이 바로 아키텍처 수준에서 OCP가 동작하는 방식이다.**

> 중요한 점은 모든 관계는 단방향으로 이뤄진다.

<br>

또 하나의 중요한 점은 인터페이스의 사용이다.

* **방향성 제어**
  * `FinancialDataGateway`인터페이스
  * 이 인터페이스는 두 클래스 사이제 위치하며, 의존성을 역전시킨다.
* **정보 은닉**
  * `FinancialReportRequester` 인터페이스는 Controller로부터 Interactor의 정보를 은닉하기 위해 존재한다.
  * 다시 말해 **Interactor의 변경으로부터 Controller를 보호한다.**

<br>

> 다시 한번 느끼지만, 중요한 것은 컴포넌트 사이에서 보호하는 것인 듯 하다.

<br>

## 쉬운 예제 1

<p align="center"><img src="./image/image-20200723164410696.png" width="300" /><br>출처 : 스프링 입문을 위한 자바 객체 지향의 원리와 이해</p>

* `운전자`는 `마티즈`와 `쏘나타`의 변화에 따라 행동이 `의존적`으로 변하게 된다.
  * `운전자`가 `마티즈`를 운전하다가 차를 `쏘나타`로 바꾸면 기어와 창문의 조작 방법이 달라 `운전자`가 변화가 필요하다.

<p align="center"><img src="./image/1541913950879.png" width="300" /><br>출처 : 스프링 입문을 위한 자바 객체 지향의 원리와 이해</p>

* 상위 클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 객체 지향 세계의 `운전자`는 운전 습관에 영향을 받지 않게 된다.
* 다양한 `자동차`가 생긴다고 하는 것은 자동차 입장에서는 자신의 확정에는 개방돼 있는 것이고, `운전자` 입장에서는 주변의 변화에 폐쇄돼 있는 것이다.

<br>

## 쉬운 예제 2

<p align="center"><img src="./image/1541914244823.png" width="400" /></p>

* **DB의 확장에는 열려있고, JDBC인터페이스의 변화는 닫혀있다.**

<br>

## 쉬운 예제 3

JVM

* 개발자가 작성한 소스코드는 운영체제의 변화에 닫혀 있고, 각 운영체제별 JVM은 확정에 열려있는 구조가 된다.

<br>

## 쉬운 예제 4

<p align="center"><img src="./image/151351513.png"></p>

* 편의점에서 일일 삼교대로 직원이 교대한다. 직원이 바뀐다고 해서 손님이 구매라는 행위를 하는 데는 영향이 없다.

<br>

# 생각해볼 점
* OCP를 적용하는 방법은 상속(is-a)와 컴포지션(has-a)가 있다고 볼 수 있다.
  * 상속은 하위 클래스가 상위 클래스에 강하게 의존하므로, 인터페이스를 이용한 컴포지션이 더 유연하다.
  * 부모 클래스에서 자식 클래스를 만들 때, 자식 클래스에서 기능을 추가/수정 할 수 있지만, 자식 클래스를 위해 부모 클래스가 수정될 필요는 없다.
* 변화가 예상되는 부분을 추상화하는 것이기 때문에 너무 먼 미래를 생각하다보면 오히려 구조가 복잡해질 수 있다.
  * [YAGNI](https://ko.wikipedia.org/wiki/YAGNI)
* OCP를 적용하다보면 depth가 3단계, 4단계로 불어나며 오히려 프로그램의 복잡도가 증가하는 경우는?
  * 적절한 단계에서 제어하는 게 중요한 것 같다. 과도한 사용은 되려 프로그램의 본질을 퇴색할 수 있다고 생각한다.

<br>

# 참고
* [스프링 입문을 위한 자바 객체 지향의 원리와 이해](http://www.yes24.com/Product/Goods/17350624)
* [클린 아키텍처](http://www.yes24.com/Product/Goods/77283734?OzSrank=1)
