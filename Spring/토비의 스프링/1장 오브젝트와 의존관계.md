<img src="./image/800x0.png" width="250" />

[토비의 스프링](http://www.yes24.com/Product/Goods/76074405?OzSrank=2)을 바탕으로 작성한 자료입니다.





# 목차





# 1장 오브젝트와 의존관계

스프링은 자바를 기반으로 한 기술이다.  

스프링이 가장 관심을 많이 두는 대상은 ***객체***다. 스프링을 이해하려면 먼저 객체에 깊은 관심을 가져야 한다.

***1장에서는 스프링이 어떤 것이고, 무엇을 제공하는지보다는 스프링이 관심을 갖는 대상인 객체의 설계와 구현, 동작원리에 더 집중한다.***

핵심은 ***관심사 분리***이다.



## 1 초난감 DAO

사용자 정보를 JDBC API를 통해 DB에 저장하고 조회할 수 있는 간단한 DAO를 만드는 예시를 보여준다.

![image-20200829215309664](./image/image-20200829215309664.png)

[초난감 DAO 코드](https://github.com/binghe819/toby-spring-code/blob/master/Ch01/src/main/java/user/dao/UserDao.java)

위 코드를 보면 DAO가 혼자 북치고 장구치고 다 한다. **여러 관심사항으로 나눠보면 아래와 같다.**

* "커넥션"에 대한 **관심**
* DB에 보낼 sql을 만들고 실행하는 **관심**
* 리소스를 반환하는 **관심**

:scream: 이렇게 한 코드에 **여러 관심사항이 존재**하면 ***중복***코드를 야기하며, 훗날 ***변경이 일어나게 된다면*** 굉장히 지저분한 코드가 된다.

  

## 2 DAO의 분리

🤔 ***관심사의 분리***

* **관심이 같은 것끼리는 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.**
* **변화도 한 곳에서 일어나게 해야한다.**



### 2-1 중복 코드의 메서드 추출

🤔 **메서드 추출 기법**

* 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것을 말한다.

[메서드 추출 기법 코드](https://github.com/binghe819/toby-spring-code/blob/master/Ch01/src/main/java/user/dao/UserDaoMethodExtraction.java)

😎 독립적인 메서드로 추출함으로써 한 가지 **관심**에 ***변경이 일어나면*** 관심이 집중되는 코드만 수정해주면 된다.

* 위 코드에서는 `getConnection()`으로 **DB의 커넥션 관련 관심**을 분리한 것이다.



### 2-2 상속을 통한 확장 (팩토리 메서드 패턴)

:scream: 문제점은 위 코드를 여러 업체에 제공하게 된다면, 업체마다 사용하는 DB가 다를 수도 있고, `userDao` 의 코드를 노출하기 싫을 수도 있다. 이때 추상화를 한다.

![image-20200830013247861](./image/image-20200830013247861.png)

[상속을 통한 확장 코드 - 팩토리 메서드 패턴](https://github.com/binghe819/toby-spring-code/blob/master/Ch01/src/main/java/user/dao/FactoryMethodPattern/abstractUserDao.java)

😎 DB 커넥션에 대한 관심을 ***추상 메서드***로 제공함으로써, `userDao`에 대한 코드를 제공하지 않고, 각 업체마다 커넥션에 대한 관심을 따로 설정할 수 있게 되었다. - 관심 분리 - 

> 템플릿 메서드 패턴과 팩토리 메서드 패턴의 대한 정의는 [용어 정리](#용어-정리)를 참고하자.



👍 **`userDao`**는 ***어떤 기능을 사용한다는 데에만 관심을 집중***하면 되고, **서브 클래스**에서 **어떤 커넥션을 제공하면 되는 지에 대한 관심**을 갖는 것이다.

* `UserDao` : 어떻게 데이터를 등록하고 가져올 것인가에 대한 관심 (핵심 기능)
* `NUserDao`, `DUserDao` : DB 연결 방법은 어떻게 할 것인가에 대한 관심

<img src="./image/image-20200830021023433.png" width="700" />

:scream: 상속을 사용하는데 따르는 단점이 있다.

* 다중 상속을 허용하지 않는다.
* 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다.
  * 서브 클래스는 슈퍼클래스의 기능을 직접 사용가능하므로, 슈퍼 클래스 내부의 변경이 서브클래스의 수정을 불러올 수 있다.
* 해당 DB 커넥션을 생성하는 코드를 다른 `dao`클래스에 적용할 수 없다.





## 3 DAO의 확장

:scream: 상속을 통한 클래스 분리는 상하위 클래스가 밀접한 관계가 있으므로 제대로 분리했다고 보기 어렵다.



### 3-1 클래스 분리

🤔 **클래스 분리**

<img src="./image/image-20200901135703490.png" width="600" />

[클래스 분리 코드](https://github.com/binghe819/toby-spring-code/tree/master/Ch01/src/main/java/user/dao/ClassSeparation)

* 아예 상속관계가 아닌 **독립적인 클래스**를 만들어 **의존 관계를 만드는 방식.**
  * DB 커넥션 관심 : `SimpleConnectionMaker`
  * 데이터 액세스 관심 : `UserDao`

😎 `DB 관심`과 `데이터 액세스 관심`을 완벽히 분리해냈다. 상속으로 인한 문제는 없다.

:scream: N사와 D사에 `UserDao`클래스만 공급하고 상속을 통해 `DB 커넥션 기능`을 **확장하는 것이 불가능해졌다.**

* 첫번째 문제, 책임은 동일하지만 **메시지의 이름이 통일이 안된다.**
  * N사는 `openConnection`, D사는 `getConnection`이라고하면 `UserDao`는 하나하나 코드를 수정해줘야 한다.
* 두번째 문제, `UserDao`가 **특정한 객체에 너무 의존적이다.**
  * `UserDao`가 `DB 커넥션`객체에 대해 너무 많이 알고있어야 한다. 



### 3-2 인터페이스 도입

🤔 **인터페이스 분리**

<img src="./image/image-20200901140809825.png" width="600" />

[인터페이스 분리 코드](https://github.com/binghe819/toby-spring-code/tree/master/Ch01/src/main/java/user/dao/OCP)

* 인터페이스를 통해 두 개의 클래스 사이에 느슨한 연결고리를 만들어주는 것.
* OCP (개방-폐쇄 원칙)을 적용한 것과 같다.

😎 `DB 관심`과 `데이터 액세스 관심`사이에 **인터페이스를 통해 느슨한 관계를 만들어주었고**, **책임을 통일시키므로써 메시지의 이름이 통일되었다.** (자율적인 객체)

:scream: 메시지 이름이 통일 안되는 문제는 해결했지만, **특정한 객체에 아직도 너무 의존적이다.**

<img src="./image/image-20200901142818274.png" width="550" />

* 아직도 `UserDao`코드에선 `DB 커넥션`에 대한 특정한 객체의 이름이 필요하다. (`DConnectionMaker`)



> 외부에서 의존성을 주입해주는 다음 방식을 통해 이를 해결할 수 있다.





### 3-3 의존성 주입 (책임 분리)

:scream: 문제는 `UserDao`가 특정 클래스와 관계를 가져서는 안된다는 것이다. 의존성 주입을 통해 관계를 끊어보자.



🤔 **의존성 주입**



🤔 **의존성 주입**

<img src="./image/IMG_B980FB57351E-1.png" width="650" />

[의존성 주입 코드](https://github.com/binghe819/toby-spring-code/tree/master/Ch01/src/main/java/user/dao/ConstructorInjection)

* 기존엔 `UserDao`가 `DB 커넥션 관심`과 관계를 맺는 책임이 있었지만, 이를 **클라이언트에게 넘긴 것이다.**
  * **클라이언트는 `UserDao`를 사용하기 위해서는 `DB 커넥션`에 대한 의존성을 주입해주어야한다.**
* 이제 **`UserDao`의 모든 코드는 `ConnectionMaker` 인터페이스 외에는 어떤 클래스와도 관계를 가지지 않는다.**
  * `DB 커넥션 관심`과 `데이터 액세스 관심`을 완벽히 분리해낸 것이다.

😎 `UserDao`는 이제 자신의 관심사이자 책임인 `데이터 액세스`에만 집중할 수 있게되었다. (책임 분리)

* `DB 커넥션`을 가져오는 방법은 어떻게 변경하든 `UserDao` 코드는 아무런 영향을 받지 않는다.



> **OCP (개방 폐쇄 원칙)과 생성자를 이용한 의존성 주입을 통해 책임을 분리하는 방식이다.**





## 4 제어의 역전

제어의 역전이 뭘 가리키며, 어떻게 사용되는지 알아보자.



### 4-1 제어의 역전

🤔 **제어의 역전이란?**

* 프로그램의 제어 흐름 구조를 뒤바꾸는 것.
  * 기존엔 `main`부터 시작해서 모든 객체가 능동적으로 `new`를 통해 자신이 사용할 클래스를 결정하고 관리했다.
  * **제어의 역전에서 객체는 자신이 사용할 오브젝트를 스스로 선택하지 않고, 주입 받는다.**
* **모든 제어 권한을 자신이 아닌 다른 대상에게 위임하는 것.**

<img src="./image/image-20200901171246166.png" width="350" />

* **컨테이너(팩토리)가 모든 컴포넌트(객체)들을 관리하고 주입해주는 역할을 함으로써 제어의 역전을 구현한다.**



🤔 **컨테이너(팩토리)가 하는 일은?**

* 컴포넌트의 생성과 관계 설정
* 컴포넌트 사용
* 컴포넌트 생명주기 관리



:point_right: **예시**

* 서블릿
  * 서블릿 안에는 `main`이 없고, 대신 서블릿에 대한 제어 권한을 가진 컨테이너가 서블릿 객체를 만들어 메서드를 호출한다. 이러한 컨테이너 안에서 동작하는 구조도 제어의 역전이라고 할 수 있다.



### 4-2 객체 팩토리

:scream: 지금까지 책임을 잘 분리했지만, 문제는 `UserDaoTest`가 테스트와 의존성 주입이라는 두 가지의 역할을 맡고 있었다. 이를 분리시켜야 한다.

* 테스트 관심 == 테스트코드
* `데이터 액세스 관심(UserDao)`와 `DB 커넥션 관심(ConnectionMaker)`의 의존성을 만들어주는 관심 == 팩토리



🤔 **팩토리 == 설계도**

<img src="./image/image-20200901153335797.png" width="650" />

```java
public class DaoFactory {
  public UserDao getUserDao(){
    return new UserDao(new NConnectionMaker());
  }
}
```

[팩토리 적용한 코드](https://github.com/binghe819/toby-spring-code/tree/master/Ch01/src/main/java/user/dao/IoC)

* 팩토리란?
  * 객체의 생성 방법을 결정하고 그렇게 만들어진 객체를 돌려준다.
* **`DaoFactory(팩토리)`의 `getUserDao()`를 호출하면 `DConnectionMaker(DB커넥션관심)`이 담긴 `UserDao (데이터 액세스 관심)`을 반환해준다.**

  

🙋‍♂️ **설계도로서의 팩토리 (핵심)**

* 컴포넌트 : **실질적인 로직을 담당하는 컴포넌트**
  * `UserDao` : 핵심적인 데이터 로직
  * `ConnectionMaker` : 데이터 기술 로직
* 설계도 : 애플리케이션을 구성하는 **컴포넌트의 구조와 관계를 정의**
  * **`DaoFactory` : 애플리케이션의 객체들을 구성하고 그 관계를 정의하는 책임**



> 새로운 `ConnectionMaker`구현 클래스로 변경이 필요하면 `DaoFactory(설계도)`를 수정해주면 된다.



### 4-3. 팩토리의 활용

🤔 `DaoFactory`에 `UserDao`말고 다른 `DAO`의 생성 기능을 넣으려면 어떻게 할까?

<img src="./image/image-20200901164724115.png" width="550" />

* 중복이 발생하게 된다.

😎 위에서 사용한 것처럼 메서드 추출 기법을 사용하면 중복을 제거할 수 있다.

<img src="./image/image-20200901164824275.png" width="550" />



> **`DaoFactory`가 바로 IoC에서 컴포넌트들을 관리하는 `컨테이너(팩토리)`에 해당한다.**









# 용어 정리



## DAO

🤔 DAO란?

DAO (Data Access Object)는 **DB를 사용해 데이터를 조회하거나 조작하는 기능**을 전담하도록 만든 오브젝트를 말한다.





## 자바빈

🙋‍♂️ 자바빈은 두 가지 관례를 따라 만들어진 오브젝트를 가리킨다.

* 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
* 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. Getter / Setter를 사용해 수정 또는 조회할 수 있다.



## 리팩토링

🤔 리팩토링이란?

* 리팩토링은 기존의 코드를 ***외부의 동작방식에는 변화 없이 내부 구조를 변경***해서 재구성하는 작업 또는 기술을 말한다.

😎 리팩토링을 하면?

* 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응 할 수 있다.
* 결국 생산성이 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다.

🤔 나쁜 냄새

* 리팩토링이 절실히 필요한 코드의 특징을 나쁜 냄새라고 부르기도 한다.
* 대표적으로 나쁜 냄새는 중복 코드다.



## 디자인 패턴

🤔 디자인 패턴이란?

* 디자인 패턴은 소트프웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다.



## 템플릿 메서드 패턴

🤔 템플릿 메서드 패턴이란?

* Template : 견본, 본보기, 형판
* 슈퍼클래스에 기본적인 로직의 흐름 (커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메서드로 만든뒤 서브클래스에서 이런 메서드를 필요에 맞게 구현해서 사용하도록 하는 방법
* 즉, ***상속을 통해 슈퍼 클래스의 기능을 확장***할 때 사용하는 가장 대표적인 방법이다.
* ***슈퍼 클래스에서 큰 틀을 만들고, 하위 클래스에서 세부 사항을 변경하도록 강제시켜 사용하는 패턴***

:point_right: 코드로 보는 템플릿 메서드 패턴

```java
public abstract class Super {
  public void templateMethod(){
    // 기본 알고리즘 코드
    hookMethod();
    abstractMethod();
    ...
  }
  protected void hookMethod(){} // 선택적으로 오버라이드 가능한 훅 메서드
  public abstract void abstractMethod(); // 서브클래스에서 반드시 구현해야 하는 추상 메서드
}

public class Sub1 extends Super {
  protected void hookMethod(){ // 선택적 오버라이딩
    ...
  } 
  public void abstractMethod() { // 반드시 구현
    ...
  }
}
```





## 팩토리 메서드 패턴

🤔 팩토리 메서드란?

* 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메서드를 팩토리 메서드라고 한다.
* **주로 인터페이스 타입으로 리턴을 한다.** 
* **자바에서는 종종 객체를 생성하는 기능을 가진 메서드를 일반적으로 팩토리 메서드라고 부른다고 한다.**

<img src="./image/image-20200830022752375.png" width="550" />

🤔 팩토리 메서드 패턴이란?

* ***서브클래스에서 구체적인 객체(Connection) 생성 방법을 결정하게 하는 것***

* 팩토리 메서드 패턴도 템플릿 메서드 패턴과 동일하게 ***상속을 통해 기능을 확장***하는 패턴이다.

* ***슈퍼클래스는 서브클래스에서 구현할 메서드를 호출해서 필요한 타입의 객체를 가져와 사용한다.***

  



## 개방 폐쇄 원칙

🤔 개방 폐쇄 원칙이란?

* 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야 한다
* 인터페이스를 통해 두 클래스 사이에 느슨한 관계를 만들어주어 확장에 열려있게 하는 것이다.
* 예시
  * JDBC





## 높은 응집도와 낮은 결합도



🤔 **높은 응집도란?**

* 응집도가 높다는 건 하나의 모듈, 클래스가 **하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.**
  * 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.



🤔 **낮은 결합도란?**

* 책임과 관심사가 다른 객체간의 느슨한 연결을 유지하는 것을 낮은 결합도라고 한다.
* 결합도란?
  * 하나의 객체가 변경이 일어날 때 관계를 맺고 있는 다른 객체에게 변화를 요구하는 정도
* 낮은 결합도란 결국, 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다.



## 전략 패턴



🤔 전략 패턴이란?

* 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴
* 꼭 알아야하는 세 요소
  * 전략 메서드를 가진 전략 객체
  * 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
  * 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)

<img src="./image/CamScanner 08-07-2020 00.20.00_1.png" width="400" />

* `OCP + 생성자를 통합 의존성 주입`가 좋은 예시이다.





## 프레임워크 vs 라이브러리

🤔 프레임워크와 라이브러리

* 제어
  * 라이브러리를 사용하는 코드는 애플리케이션 흐름을 직접 제어한다. (능동)
  * 프레임워크는 거꾸로 코드가 프레임워크에 의해 사용된다. (수동) - 제어의 역전
    * 컴포넌트의 생성과 관계 설정, 사용, 생명주기 관리등을 관장한다.











