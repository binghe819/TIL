# 목차

<br>

- [목차](#목차)
- [들어가며](#들어가며)
- [단위 테스트 구조](#단위-테스트-구조)
- [테스트 픽스처 재사용](#테스트-픽스처-재사용)
- [단위 테스트 명명법](#단위-테스트-명명법)
- [매개변수화된 테스트 리팩터링](#매개변수화된-테스트-리팩터링)

<br>

# 들어가며
이번장에선 단위 테스트를 구성하는 구조에 대해서 다룬다.
1. 단위 테스트 구조(Given-When-Then). 그리고 왜 xUnit을 선택했는지
2. 단위 테스트 명명법
3. 단위 테스트 프로세스를 간소화하는 데 도움이 되는 프레임워크 (매개변수화된 테스트)

<br>

# 단위 테스트 구조
이 절에서는 준비, 실행, 검증 패턴을 사용해 단위 테스트를 구성하는 방법인 Given-When-Then 스타일을 소개한다.

그리고 피해야 할 함정 그리고 테스트의 가독성을 높이는 방법에 대해서 다룬다.

<br>

🤔 Given-When-Then 스타일이란?

* Given: 준비 구절
  * SUT (System Under Test, 테스트 대상 시스템)과 해당 의존성을 원하는 상태로 만드는 단계
* When: 실행 구절
  * SUT에서 메서드를 호출하고 준비된 의존성을 전달하며 실행하는 단계.
* Then: 검증 구절
  * SUT 실행의 결과를 검증하는 단계.
* 종료 단계
  * 테스트에 작성된 파일을 지우거나 DB 연결을 종료할 때 사용되는 단계.

```java
// 예시
@Test
void sum() {
    // given
    double first = 10;
    double second = 20;
    Calculator calculator = new Calculator();

    // when
    double result = calculator.sum(first, second);

    // then
    assertThat(result).isEqualTo(30);
}
```

<br>

💁‍♂️ Given-When-Then 작성시 피해야 할 부분

* 여러 개의 준비, 실행, 검증 구절은 피하라
  * 단위 테스트이므로 하나의 준비, 실행, 검증 구절만 존재하는 것이 좋다.
  * 실행 구절이 여러 개면 통합 테스트로 보는게 좋다. (개인적으로 통합 테스트도 하나의 구절만 존재하는 것이 좋다고 생각한다.)
* 테스트 내 if문 피하기
  * 테스트는 단위 테스트든 통합 테스트든 분기가 없는 간단한 일련의 단계로 테스트가 진행되어야한다.
  * if문이 테스트 안에 너무 많으면 한 테스트에서 너무 많은 것을 검증한다는 의미이므로 좋지 않다.

<br>

💁‍♂️ 각 구절은 얼마나 커야하는가?

* Given
  * 일반적으로 준비 구절이 세 구절 중 가장 크며, 실행과 검증을 합친 만큼 클 수도 있다.
  * 물론 너무 커지면 메서드 추출 도는 별도의 팩토리 클래스로 도출하는 것이 좋다.
  * 코드 재사용에 도움되는 두 가지 패턴
    1. 오브젝트 마더 (Object Mother)
    2. 테스트 데이터 빌더 (Test Data Builder)
* When
  * 실행 구절은 한 줄로 딱 하나의 메서드만 호출하는 것이 좋다.
  * 진입점을 오직 하나만 존재하는 것이 좋다. 
* Then
  * 단위 테스트는 동작의 단위이지 코드의 단위가 아니다.
  * 그러므로 꼭 하나의 검증문만 존재할 필요는 전혀 없다.
* 종료 단계
  * 사실 대부분의 단위 테스트는 종료 단계가 필요없다. 
  * 종료는 보통 통합 테스트의 영역이다.

> 각 테스트는 격리되어야한다. 준비 과정을 줄일려고 테스트 간의 상태를 공유하면 추후에 테스트 간의 간섭으로 인해 문제가 발생할 확률이 높다. (특히 데이터베이스)

<br>

# 테스트 픽스처 재사용
테스트 간의 준비 단계를 줄이기위해 테스트 픽스처를 재사용하는 경우가 많다.

이번 절에선 테스트 픽스처를 사용할 때의 주의할 점에 대해서 다룬다.

<br>

🤔 텍스트 픽스처?

* 여러 테스트에서 공통적으로 사용되는 의존성이나 상태를 별도의 메서드나 클래스, 상태로 도출하여 테스트 간에 재사용하는 것을 의미한다.
  * ex. DB 데이터, static 상태등
* 텍스트 픽스처 방식
  * 생성자 (ex. JUnit에서의 `@BeforeEach`)
  * 비공개 팩토리 메서드 (ex. 메서드 추출)

<br>

💁‍♂️ 생성자 방식은 편하지만 두 가지 단점을 가진다.

* 생성자 방식의 장점
  * 공통된 준비 로직을 생성자로 완전히 추출하여 불필요한 중복을 제거할 수 있다.
* 문제점은... (큰 문제!)
  * **테스트 간의 높은 결합도**
    * 테스트 간의 공유되는 의존성과 상태로 인해 결합도가 높아진다.
    * 만약 생성자의 픽스처를 수정하면 특정 테스트에 간섭이 생겨 실패하는 경우가 발생할 확률이 높다.
  * **가독성을 떨어트리는 생성자**
    * 테스트만 보고는 해당 테스트의 큰 그림을 그릴 수 없다.
    * 매번 생성자로 왔다갔다해야 테스트의 그림을 그릴 수 있기에 좋다고 볼 수 없다.

<br>

💁‍♂️ 더 나은 테스트 픽스처 방법으로는 비공개 팩토리 메서드가 있다.

```java
// 비공개 팩토리 메서드 예시
private Store createStoreWithInventory(Product product, int quantity) {
    Store store = new Store();
    store.addInventory(product, quantity);
    return store;
}
```

* 장점
  * 가독성이 좋다.
  * 매 테스트간의 간섭이 발생하지 않으므로 결합도가 높아지지 않는다.
* 단점
  * 매 테스트 클래스마다 비공개 메서드를 만들어줘야하므로 팩토리 메서드가 중복될 수 있다.
  * 만약 팩토리 메서드를 담고 있는 static 클래스를 둔다면, 테스트 클래스간의 결합도가 높아질 수도 있다.. (후...)

<br>

💁‍♂️ 상속을 이용한 방식

```java
// 스프링에서의 통합 테스트 상위 클래스 예시
@ActiveProfiles("test")
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
public class IntegrationTest {

    @Autowired
    private DatabaseCleaner databaseCleaner;

    @AfterEach
    void tearDown() {
        databaseCleaner.clear();
    }
}
```
* 위와 같이 통합 테스트에서 DB를 사용하는 경우, DB와 관련된 로직을 상위 클래스에 두고 통합 테스트마다 상속받아 사용하는 방식이다.

> 이 내용은 스프링에 의존적으로 얘기가 될 것 같아서 간단히만 다루고, 자세한 내용은 [여기](https://github.com/binghe819/TIL/blob/master/Spring/Test/DB%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EA%B2%A9%EB%A6%AC/DB%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EA%B2%A9%EB%A6%AC.md)에 정리해두었다.

<br>

# 단위 테스트 명명법
사실 정해진 룰은 없다. 팀마다 각자 알아서 정하는 것이 좋다고 생각든다.

필자의 경우는 한글로 작성하며, 팀의 컨벤션을 지켜서 작성하려고 노력한다.

<br>

# 매개변수화된 테스트 리팩터링
보통 테스트 하나로든 동작 단위를 테스트하기 어렵다.

예를 들어, 더하기 기능의 실패 테스트를 작성한다고 가정한다면, 값을 넣지 않거나 하나의 값만을 넣으면 예외가 터지고 테스트는 성공하게 된다.

값을 넣지 않는 것과 하나의 값을 넣는 것 -> 이것만으로도 하나의 동작 (실패 테스트)를 위해 두 개의 테스트 코드를 중복해서 생성해줘야한다.

이를 굉장히 비효율적! 이 문제를 해결하기 위해 xUnit은 대부분 매개변수화된 테스트를 제공한다.

스프링의 경우 `@ParameterizedTest`가 대표적이다.



