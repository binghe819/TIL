# 목차

<br>

<br>

# 1 주소 공간
* 주소란
  * 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자로 구성된 단위.
* 컴퓨터는 이진수로 주소를 표현한다.
  * 컴퓨터는 보통 32비트 혹은 64비트의 주소 체계를 사용한다. (운영체제보면 32bit, 64bit가 존재함.)
* 컴퓨터는 byte단위로 메모리 주소를 부여한다.
  * 32비트 주소체계(4바이트)는 2^32바이트, 64비트 주소체계(8바이트)는 2^64바이트의 서로 다른 메모리 위치를 구분할 수 있다.
* 은유
  * 현실에서의 주소: 계층적으로 행정구역을 묶어서 주소를 표현한다. (ex. 서울시 서대문구 이화여대길 52번지)
    * 전체 주소 중 52번지는 건물 번호처럼 자세한 주소를 나타낸다.
  * 컴퓨터에서의 주소: 보통 4KB(2^12바이트, 32000비트) 단위로 묶어서 페이지라는 행정구역을 묶어서 주소를 표현한다. (32비트 주소체계 기준)
    * 페이지 하나의 크기가 4KB이므로, 페이지내에서 바이트별 위치 구분을 위해선 12비트가 필요하다.
    * 그러므로 32비트의 주소 중 하위 12비트(하나의 페이지)는 페이지 내에서의 주소를 나타내게 된다.

<br>

# 2 주소 바인딩

<br>

<p align="center"><img src="./image/address_binding.png"><br>출처: 운영체제 수업. 반효경 </p>

💁‍♂️ **논리적 주소와 물리적 주소**
* 논리적 주소 (가상 주소)
  * 메모리에 적재되는 프로세스를 위한 독자적인 주소 공간.
  * 논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.
* 물리적 주소
  * 물리적 메모리(RAM)에 실제로 올라가는 위치를 말한다.
  * 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

🤔 **주소 바인딩이란?**
* 프로세스가 실행되기 위해선 어쨋든 물리적 메모리에 올라가 있어야 한다.
* **이렇게 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소 바인딩이라고 한다.**
  * 주소 바인딩 = 물리적 주소와 논리적 주소의 매핑.

<br>

💁‍♂️ **주소 바인딩의 3가지 방식.**

물리적 주소와 논리적 주소를 바인딩하는 방법은 크게 3가지가있다.

1. **컴파일 타임 바인딩: 컴파일 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지 결정.**
  * 프로그램이 절대주소로 적재된다는 의미. 주소를 변경하기 위해선 다시 컴파일 해야한다.
  * 따라서 컴파일 타임 바인딩은 비현실적이고, 현대의 시분할 컴퓨팅 환경에서는 잘 사용되지 않는다.
2. **로드 타임 바인딩: 프로그램 실행 시점에 로더에 의해 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지 결정.**
  * 프로그램이 종료될 때까지 물리적 메모리상의 위치는 고정된다.
  * 로더 -> 사용자 프로그램을 메모리에 적재시키는 프로그램. (JVM도 클래스로더가 존재한다.)
3. **실행시간 바인딩: 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리 상의 주소가 변경될 수 있는 방식.**
  * CPU가 메모리를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블을 이용해 바인딩을 점검해야한다.
  * 또한, **실행시간에 바인딩을 점검하고 변경할 수 있기때문에 기준 레지스터와 한계 레지스터를 포함해 MMU (메모리 관리 유닛)라는 하드웨어의 지원이 필요하다.**

> 실제 많이 사용되는 시분할 시스템에선 실행시간 바인딩을 디폴트로 사용한다.

<br>

🤔 **MMU 기법**

<p align="center"><img src="./image/mmu.png"><br>MMU 기법에 의한 주소 변환 </p>

* **논리적 주소 + 기준 레지스터 값 => 물리적 주소**
  * **CPU가 논리적 주소를 참조하려고 할 때 MMU기법은 그 논리적 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다.**
  * 즉, **MMU기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다.**
* **기준 레지스터 (재배치 레지스터): 현재 CPU에서 수행 중인 프로세스의 물리적 메모리 시작 주소가 저장되어 있다.**
  * MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되기때문에, **프로세스마다 물리적 메모리상의 시작 주소만 알면 수조 변환을 쉽게 할 수 있다.**
  * **기준 레지스터에는 각 프로세스별 물리적 메모리 시작 주소가 저장된다.**
* **MMU 기법에선 사용자 프로그램이나 CPU는 논리적 주소만 다룰 뿐, 물리적 주소는 알지 못하며 알아야 할 필요도 없다.**

> 

<br>

💁‍♂️ **MMU로인해 각 프로세스의 논리적 주소가 같더라도 실제 물리적 메모리에선 서로 다른 내용을 담고있다.**

MMU는 컨텍스트 스위칭으로 CPU에서 수행 중인 프로세스가 바뀔 때마다 기준 레지스터의 값을 그 프로세스에 해당하는 값으로 재설정함으로써 각 프로세스에 맞는, 서로 다른 주소에 접근한다.

<br>

💁‍♂️ **한계 레지스터의 필요성**

**보통 물리적 메모리에선 여러 개의 프로세스가 동시에 올라가 실행된다. 이때 CPU가 요청한 논리적 주소값를 통해 물리적 주소값을 구했더니 해당 프로세스의 주소 공간을 벗어날 수도 있다.**

만약 A프로세스의 논리적 주소값을 통해 물리적 주소값을 구했는데, 다른 프로세스의 물리적 주소값을 침범한다면 **메모리 보안상 치명적인 결과를 초래한다.**

**OS는 이러한 문제를 해결하기위해 한계 레지스터를 사용한다.**

<br>

🤔 **한계 레지스터**

<p align="center"><img src="./image/mmu_2.png"><br>기준 레지스터와 한계 레지스터에 의한 주소 변환 </p>

1. CPU가 요청한 프로세스의 논리적 주소값이 한계 레지스터에 저장된 프로세스의 크기보다 작은지 확인.
2. 작다면 노리적 주소값에 기준 레지스터값을 더해 물리적 주소에 접근한다.
   * 크다면 트랩을 발생시켜 해당 프로세스를 강제 종료시킨다.

<br>

**한계 레지스터는 위와 같이 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고하는지 체크하는 용도로 사용된다.**

**이를 위해 현재 CPU에서 수행중인 프로세스의 논리적 주소의 최댓값, 즉 그 프로세스의 크기를 담고있다.**

<br>

# 3 메모리 관리와 관련된 용어
메모리 관리에 필요한 다양한 용어들에 대해서 다룬다.

<br>

## 3-1 동적 로딩

🤔 **동적 로딩이란**
* 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 메모리에 모두 올려놓는 것이 아닌 사용되는 부분만 불릴때마다 올려놓는 것을 말한다.
* **지연 로딩 (lazy-loading)과 같은 의미.**

<br>

💁‍♂️ **장점**
* 여러 프로그램이 동시에 메모리에 올라가는 다중 프로그래밍 환경에서 메모리 사용의 효율을 높이기위해 사용된다.
* 예를 들어 에러처리와 같은 코드들을 실제로 많이 사용되지 않으므로 내려놓고 있다가 필요할 때만 올리게됩니다.

<br>

## 3-2 동적 연결

🤔 **연결** (link)란?
* 개발자가 작성한 소스 코드를 컴파일하여 생성된 목적 파일 (object file, 자바에선 class파일)과, 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행파일을 생성하는 과정을 말한다.
* 자바로 생각하면 사용자 소스코드와 라이브러리 코드를 합쳐서 하나의 `.jar` 파일을 만드는 과정이라고보면된다.

<br>

🤔 **동적 연결**

* 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법.

<br>

🤔 **동적 연결이 필요한 이유는?**

동적 연결과 대비되는 개념인 정적 연결을 생각하면 왜 동적 연결이 필요한지 알 수 있다.
* 정적 연결은 개발자가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성된다.
* 이렇게되면 실행파일의 크기가 생다적으로 크며, 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재함으로써 물리적 메모리 낭비가 발생한다.

<br>

💁‍♂️ **동적 연결의 장점**

* 라이브러리가 실행 시점에 연결된다.
* 즉, 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어진다.
* 또한, 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하므로 메모리 사용의 효율성을 높일 수 있다.

<br>

## 3-3 중첩

🤔 **중첩** (overlays)

* 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법을 말한다.
* 동적 로딩과 개념적으로 유사하다. 하지만, 동적 로딩과 중첩을 사용하는 이유가 상이하다.
  * 중첩은 초장기 컴퓨터 시스템에서 물리적 메모리가 부족한 상황으로 인해 하나의 프로세스조차도 메모리에 올릴 수 없을 때 사용하던 기법이다.
    * 하나의 프로세스를 메모리에 분할해서 올리기위함. (메모리 크기가 프로세스보다 작을 때 사용된다.)
  * 동적로딩은 다중프로그래밍 환경에서 메모리 이용률을 높이기위해 사용되는 기법이다.
    * 여러 프로세스환경에서 메모리 사용율을 높이기위함.

<br>

## 3-4 스와핑 기법

🤔 **스와핑**

<p align="center"><img src="./image/Swapping.jpeg"><br>출처: https://binaryterms.com/swapping-in-operating-system.html </p>

* **메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역 (swap area)에 일시적으로 내려놓는 것을 말한다.**
  * 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것. (swap out)
* 스와핑의 역할
  * **스와핑의 가장 중요한 역할은 메모리에 존재하는 프로세스의 수를 조절하는 것이다.**
* 일반적으로 중기 스케줄러에 의해 스와핑이 발생한다.

<br>

# 4 물리적 메모리의 할당 방식

<br>

💁‍♂️ **물리적 메모리 영역**

* 운영체제 상주 영역
  * 인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용하며, 운영체제 커널이 이곳에 위치한다.
* 사용자 프로세스 영역
  * 물리적 메모리의 높은 주소 영역을 사용하며, 여러 사용자 프로세스들이 이곳에 적재되어 실행된다.

<br>

💁‍♂️ **물리적 메모리의 할당 방식은 크게 2가지로 나뉜다.**

* 연속할당
  * 각각 프로세스를 물리적 프로세스의 연속적인 공간에 올리는 방식.
  * 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록한다.
  * 종류
    * 고정분할 - 물리적 메모리를 고정된 크기의 분할로 미리 나누어두는 방식.
    * 가변분할 - 분할을 미리 나누어놓지않은 채 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식.
* 불연속할당
  * 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식.
  * 종류
    * 페이징 기법 - 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 방식.
    * 세그먼테이션 - 프로그램의 주소 공간을 코드, 데이터, 스택 등 의미있는 단위로 세그먼트로 나누어 세그먼트 단위로 적재하는 방식.
    * 페이지드 세그먼테이션 - 세그먼트 하나를 다수의 페이지로 구성하는 방식.

> 사용자 프로세스 영역에서의 물리적 메모리 할당 빙식.

<br>

## 4-1 연속할당 방식

<br>

🤔 연속할당 방식

<p align="center"><img src="./image/contiguous_allocation.png"><br>출처: 운영체제 수업. 반효경 </p>

* **프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 적재하는 방식.**
* 두 가지로 나뉜다.
  * 고정분할
  * 가변분할

<br>

1️⃣ 고정분할 방식

* 개념
  * **물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 누나어두고 각 분할에 하나의 프로세스를 적재해 실행시키는 방식이다.**
* 특징
  * 이때 분할의 크기는 모두 동일하게 혹은 서로 다르게 할 수 있다. 하지만 하나의 분할에는 하나의 프로세스만 올릴 수 있는 것은 동일하다.
* 단점 1
  * **동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어있으며, 수행 가능한 프로그램의 최대 크기도 제한한다.** (융통성이 떨어진다.)
* 단점 2
  * **외부조각과 내부조각 문제가 발생한다.**
    * 외부조각이란 프로그램의 크기보다 분할의 크기가 작은 경우 해당 분할이 비어있는데도 불구하고 다른 프로그램이 적재하지못하는 메모리 공간을 의미한다.
    * 내부조각은 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간을 의미한다.
  * **이는 메모리 낭비를 유발한다.**

<br>

2️⃣ 가변분할 방식

* 개념
  * 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식.
* 내부조각은 발생하지않지만, 외부조각이 발생할 수 있다.
  * 분할의 크기를 프로그램의 크기보다 일부러 크게 할당하지않기때문에 내부 조각은 발생하지 않는다.
  * 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게되어 외부조각이 발생할 확률은 존재한다.
* 동적 메모리 할당 문제
  * 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내 가용 공간 중 어떤 위치에 올릴지 결정하는 문제를 말한다. - 외부조각을 최대한 피하기 위해선 중요한 문제이다.
  * 3가지 방법이 존재한다.
    * 최초적합 - 메모리 가용공간중 프로그램 크기보다 작은면 건너뛰고, 그렇지않으면 최초로 발견한 공간에 프로그램을 올리는 방식.
    * 최적적합 - 모든 메모리를 순회하여 새로운 프로그램을 할당할 수 있는 가장 이상적인 공간을 찾아 할당하는 방식. (속도면에서 좋지않다.)
    * 최악적합 - 모든 메모리를 순회하여 가장 크기가 큰 곳에 새로운 프로그램을 할당하는 방식. (속도, 공간면에서 좋지않다.)
  * 실험결과로는 최초적합과 최적적합이 속도와 공간 이용률 측면에서 효과적이라고한다.

<br>

> 이외에도 컴패션이라고.. 수행 중인 프로세스의 물리적 메모리 위치를 더 효과적인 공간으로 옮기는 방식이있는데, 현실적으로 구현이 복잡하며 성능상으로도 좋지않다.

<br>

## 4-2 불연속할당 기법

🤔 불연속할당 방식

* **하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법.**
* 종류
  * 페이징 기법 - 하나의 프로그램을 분할하는 기준에 따라 동일한 크기로 나누어 메모리에 올리는 기법.
  * 세그먼테이션 - 크기는 일정하지 않지만 의미 단위로 나누어 메모리에 올리는 기법.
  * 페이지드 세그먼테이션 - 세그먼테이션을 기본으로 하되 이를 다시 동일 크기의 페이지로 나누어 메모리에 올리는 기법.

> 페이징과 세그먼테이션은 비교적 복잡하므로 아래 글에 더 자세히 정리한다.

<br>

# 5 페이징 기법




