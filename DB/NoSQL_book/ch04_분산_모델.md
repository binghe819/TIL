# 목차

<br>

- [목차](#목차)
- [4장. 분산 모델](#4장-분산-모델)
- [1 NoSQL은 분산 모델 구현에 적합하다](#1-nosql은-분산-모델-구현에-적합하다)
- [2 단일 서버](#2-단일-서버)
- [3 샤딩](#3-샤딩)
- [4 Master-Slave Replication](#4-master-slave-replication)
- [5 Peer-To-Peer Replication](#5-peer-to-peer-replication)
- [6 샤딩과 복제의 결합](#6-샤딩과-복제의-결합)
- [정리](#정리)

<br>

# 4장. 분산 모델

<br>

# 1 NoSQL은 분산 모델 구현에 적합하다

💁‍♂️ **NoSQL이 매력적인 이유는 집합이 Scale-Out에 적합하기때문이다.**

NoSQL이 관심끄는 가장 큰 이유는 대규모 클러스터에서 데이터베이스를 실행할 수 있는 능력때문이다.

데이터 크기가 증가함에따라 Scale-Up은 점점 어려워지는데, 이때 매력적인 선택인 Scale-Out이다.

**NoSQL의 집합은 분산의 자연스러운 단위로 사용할 수 있으므로, 집합 지향은 Scale-Out과 잘 맞는다.**

<br>

💁‍♂️ 분산 모델은 장점도 있지만 단점도 있으므로, 잘 판단하여 사용해야한다.

* 장점
  * 더 많은 양의 데이터 처리.
  * 많은 읽기 또는 쓰기 트래픽 처리 가능.
  * 네트워크 속도가 느려지거나 장애가 발생하더라고 가용성이 더 높아진다. (고가용성)
* 단점
  * 비교적 복잡성을 감수해야함.
  * 위 장점이 필요없으면 굳이 할 필요는 없다.

<br>

💁‍♂️ 데이터 분산 방법

1. Replication (복제)
   * 같은 데이터를 복사해 여러 노드에 분산하는 방법.
   * 복제 방식엔 master-slave, peer-to-peer 두 방식이 존재한다.
2. Sharding (샤딩)
   * 각 노드마다 다른 데이터를 저장.

<br>

# 2 단일 서버

<br>

💁‍♂️ 단일 서버란

* 단일 서버는 아예 분산을 하지 않는 가장 기본적인 방법이다.
* 데이터베이스를 단일 장비에서 실행하고 읽기와 쓰기를 모두 이 한 대의 장비에서 처리하는 것.
* 다른 방식에 비해 복잡성이 없기때문에 보통 가장 선호하는 방식이다.

<br>

# 3 샤딩

💁‍♂️ 샤딩이란

* 바쁜 데이터베이스가 바쁜 이유는 많은 사람이 데이터 집합의 다른 부분에 접근하기 때문이다.
* 샤딩은 데이터의 다른 부분을 다른 서버에 두어 Scale-Out의 한 종류이다.
  * **즉, 다른 데이터를 별도 노드에 배치해, 각 노드가 각자 읽기와 쓰기를 처리한다.**
* **이상적 상황이라면 사용자마다 서로 다른 서버 노드를 사용하게 된다.**

<br>

💁‍♂️ **샤딩의 이상적인 방향**

* **함께 접근되는 데이터는 같은 모드에 모여 있게 하고, 이런 데이터 무더기를 여러 노드에 잘 배치해 최적의 데이터 접근성을 제공해야한다.**
* 이렇게되면 **부하가 여러 서로 균등하게 분산된다.**
  * 예를 들어, 서버가 열 대 있다면 각 서버가 전체 부하의 10%씩 처리하게된다.

<br>

💁‍♂️ **이상적인 방향으로 설계할 때 집합 지향이 최적이다.**

* **이상적인 방향으로 설계하는데 가장 큰 문제는 "데이터를 어떻게 뭉쳐놓으면 한 사용자가 한 서버로부터 데이터를 대부분 얻게 할 수 있느냐는 것이다."**
* **집합 지향은 바로 이 부분에 가장 잘 맞는다. 집합에서 가장 중요한 점은 함께 접근되는 빈도가 높은 데이터를 모으는 것이므로, 집합은 분산의 아주 좋은 단위가 된다. - 중요!!**

<br>

💁‍♂️ **노드에 데이터를 분배하는 것과 관련해 성능 향상에 도움되는 몇 가지 요소가 있다. - 중요**

1. 특정 집합에 대한 접근이 물리적 위치에 기반을 두고 이루어진다면 해당 데이터를 접근이 발생하는 지역에 가깝게 둘 수 있다.
   * 예를 들어, 보스턴에 사는 사람의 주문 데이터는 미국의 동부 데이터 센터에 위치시키는 것.
2. **부하를 균등하게 분배하는 것. - 가장 중요!**
   * 집합을 잘 배치해 모든 노드에 균등하게 분산하고 같은 양의 부하가 걸리도록 해야한다.
   * **부하는 균등하게 분배하기위해선 각 분야마다 사용하는 특화된 규칙을 잘 파악해서 부하 분산을 설계해야한다.**
     * 예시) 어떤 경우엔 순차적으로 읽힐 집합을 함께 두는 것이 유리하다. 실제로 빅 테이블에선 행을 사전 순서로 유지하고 웹 주소를 역 도메인 에미 (ex. com.binghe)으로 정렬한다.
       * 이렇게하면 여러 페이지에 대한 데이터가 함께 접근되어 처리 효율이 높아진다.
   * **애플리케이션 로직이 샤딩의 분산을 처리하는 역할을 가지는 것은 좋지 않다. 이렇게하면 비즈니스 로직이 복잡해지며, 샤딩의 균형을 다시 맞춰야 할 경우 애플리케이션 코드 수정과 데이터 전환이 필요하다.**
     * 예시) 성의 앞글자 A-D까지의 고객은 한 샤드에, E-G까지는 다른 샤드에 넣는 방식.
   * **가능한 샤딩은 NoSQL 데이터베이스에서 책임지게해야하며, 많은 데이터베이스가 자동 샤딩을 제공한다.**

<br>

💁‍♂️ 샤딩은 읽기와 쓰기 성능을 모두 향싱시킨다.

* 복제는 읽기 성능만 높일 수 있지만, 쓰기 성능은 향상할 수 없다.
* 반면에 샤딩은 쓰기에 대한 Scale-Out 방법도 제공하며, 읽기와 쓰기 성능 모두 향상시킬 수 있다.

<br>

💁‍♂️ **샤딩만 사용할경우 고가용성을 지키기 힘들다.**

* 샤딩에서 특정 노드가 실패하면 해당 노드에 있는 데이터를 사용할 수 없게 되므로, 기존의 단일 서버 구성와 동일한 문제가 있다.
  * 물론 해당 샤드에 데이터를 사용하는 사용자만 제대로된 서비스를 받지 못하겠지만, 고가용성이 지켜지지않는 것은 좋지않다.
* 물론 샤딩과 Replication을 잘 융합하여사용하면 고가용성을 지킬 수 있을듯 하다.

<br>

💁‍♂️ 단일 서버에서 시작해 샤딩으로 전환하는 것은 까다롭다.

* 단일 서버(노드)에서 샤딩으로 전환하는 것은 까다롭다.
* 그러므로 샤딩을 충분히 미리 적용하고, 샤딩을 수행할 여유가 충분히 있을 때 적용하는 것이 좋다.

<br>

# 4 Master-Slave Replication

💁‍♂️ Replication 이란

* 노드 하나가 마스터 노드가 되며, 마스터는 데이터에 대한 업데이트 (Write) 수행하는 역할을 맡는다. 업데이트된 내용은 슬레이브에 전파한다.
* 다른 노드는 슬레이브 노드이며, 슬레이브 노드는 읽기 (Read)를 수행하는 역할을 맡는다. 마스터 노드의 변경사항이 모두 슬레이브 노드에 반영된다. 

<br>

💁‍♂️ 읽기에 대해서 Scale-Out 할 수 있다. 그러나 쓰기에 대해선 Scale-Out이 불가능하다.

* 슬레이브 노드를 계속 추가하고 모든 읽기 요청을 슬레이브에서 처리하게함으로써 더 많은 읽기 요청을 처리할 수 있게 Scale-Out할 수 있다.
* 그러나 업데이트를 처리하고 이를 전파하므로 쓰기에 대해서 Scale-Out이 불가능하다.

<br>

💁‍♂️ 이외의 장점

* 읽기에 대해서 고가용성을 지킬 수 있다.
* 백업하는데 유용하다.

<br>

💁‍♂️ 물론 단점도 존재한다.

* 여러 노드들 간의 데이터 동기화가 완벽히 보장될 순 없기에 일관성있는 데이터를 얻지 못할 수도 있다.
* 마스터가 본질적으로 단일 장애 지점이 된다.
  * Master 노드에 의존성이 강하기 때문에 다운되면 복구 및 대처가 힘들다.

<br>

# 5 Peer-To-Peer Replication

<br>

💁‍♂️ Peer-To-Peer Replication란?

* Master-Slave Replication의 문제점
  * 읽기 확장성은 도움이 되지만, 쓰기 확장성엔 도움이 전혀 안된다. 마스터 실패에 대해서 복원력(가용성)을 제공하지 않는다.
  * 마스터가 본질적으로 단일 장애 지점이 된다.
* Peer-To-Peer Replication는 마스터를 두지 않는 구조로 이 문제를 해결한다.
  * 모든 복제본의 가중치는 동일하다. 모든 노드에서 쓰기 요청을 처리하고, 노드 중 어느 것이 실패하더라도 데이터베이스에 대한 요청이 중단되진 않는다.

<br>

💁‍♂️ 좋아보이긴하지만, 이 방식은 복잡하다. 가장 큰 단점은 일관성을 지킬 수 없다는 것.

* Peer-To-Peer Replication는 좋지만 복잡하며 일관성을 지키기 어렵다.
* 다른 두 곳에 쓸 수 있따면, 두 사람이 동시에 동일한 레코드를 업데이트하려 한다면 쓰기 충돌 위첨에 처할 수 있다.
* **읽기의 비일관성을 일시적이지만, 쓰기의 비일관성을 영구적이라 더더욱 치명적이다.**

<br>

💁‍♂️ 쓰기 비일관성을 처리하는 방법

* 트랜잭션 사용.
* 비일관적 쓰기 허용하고 병합.

<br>

# 6 샤딩과 복제의 결합

💁‍♂️ 복제와 샤딩 전략을 결합될 수 있다.

* Master-Slave + Sharding
  * 마스터가 여러 개 생기며, 샤딩의 분산기준의 각 노드마다 마스터를 하나만 갖게된다.
  * 그리고 각 마스터 노드마다 Slave를 가지게된다.

<br>

# 정리

* 데이터를 분산하는 방식은 샤딩과 복제 두 가지가 있다.
  * 샤딩
    * 샤딩은 여러 서버에서 데이터를 나눠 분산하는 방법이다.
    * 각 서버는 전체 데이터의 부분 집합을 저장하며 같은 데이터는 한 서버에서만 찾을 수 있다.
    * 읽기와 쓰기 성능 모두 향상된다.
  * 복제
    * 복제는 여러 서버에 데이터를 복사하므로, 같은 데이터를 여러 곳에서 찾을 수 있다.
* 복제는 두 가지 형태가 존재한다.
  * Master-Slave
    * 마스터는 데이터의 원본 출처가 되어 쓰기를 처리하고, 슬레이브는 마스터와 데이터를 동기화하고 읽기를 처리한다.
    * 업데이트 충돌 발생을 최소화하는 것이 좋다.
  * Peer-To-Peer
    * 모든 노드에 쓰기를 허용한다. 노드는 데이터 복사를 동기화하기 위해 조율한다.
    * 한 노드에 모든 쓰기 부담을 지우지 않도록 해 단일 장애 지점이 생기지 않도록해줘야한다.


