# 목차

<br>

- [목차](#목차)
- [5장. 일관성 (Consistency)](#5장-일관성-consistency)
- [1 쓰기 일관성](#1-쓰기-일관성)
- [2 읽기 일관성](#2-읽기-일관성)
  - [2-1 비일관적 읽기](#2-1-비일관적-읽기)
  - [2-2 비일관적 읽기의 해결책](#2-2-비일관적-읽기의-해결책)
- [3 일관성 완화](#3-일관성-완화)
- [4 지속성 완화](#4-지속성-완화)
- [5 정족수](#5-정족수)

<br>

# 5장. 일관성 (Consistency)
중앙 집중식 RDB에서 클러스터 지향 NoSQL 데이터베이스로 이동하면서 생긴 가장 큰 변화 한 가지는 일관성을 생각하는 방식이다.

RDB는 트랜잭션이라는 기능을 통해 강한 일관성을 지원한다. 반면에, NoSQL은 [CAP 정리](../CAP_PACELC/CAP_PACELC_theorem.md)에서도 알 수 있듯이 일관성에 대해서 많은 고민을 해야한다.

이번 장에선 NoSQL 사용시 일관성을 어떻게 고민해야할 지에 대해서 다룬다.

> 일관성이란?
> * **사용자가 분산 시스템상의 어떤 노드와 통신하던 상관없이 모두 같은 데이터를 조회할 수 있음을 의미한다.**
> * 따라서 일관성이 지켜진 분산 시스템은 하나의 노드에 쓰기 작업이 이루어졌다면, 이는 모든 복제본에 반영되어야한다는 의미이다. 복제본에 반영이안된다면 해당 쓰기 작업은 실패되어야한다
> * ex. 은행 잔고 조회

<br>

# 1 쓰기 일관성

<br>

💁‍♂️ **쓰기 충돌**

* 두 사람이 동시에 같은 데이터 항목을 업데이트하는 문제를 쓰기 충돌이라고한다.

<br>

💁‍♂️ **쓰기 상황에서 발생하는 일관성 깨짐**

A와 B가 동시에 전화번호를 업데이트하는 경우를 생각해본다.

* 서버는 두 요청을 직렬화해 (순서대로 정렬해 일렬로 세워) 하나를 먼저 적용하고 그 다음 다른 하나를 적용한다.
* 동시성 제어가 없다면 일관성 깨짐이 발생한다.
  * A의 업데이트는 적용된 즉시 B의 업데이트에의해 덮어쓰일 것이다.
  * 이 경우 A는 업데이트 손실을 겪게 된다.
* **여기서 업데이트 손실은 크게 상관없지만, B의 업데이트가 A 업데이트 전 값을 기반으로 동작한다는게 문제다.**
  * A가 업데이트한 값을 COMMIT하기전에, B가 이전 값을 기반으로 데이터를 수정한 것.

<br>

💁‍♂️ **쓰기 일관성을 지키기위한 두 가지 방법**

1. 비관적 접근법
   * "자원에 동시 요청이 발생하여, 데이터 일관성에 문제가 생길 것"이라고 비관적으로 생각하고 이를 방지하기 위해 자원을 선점하는 방식.
     * 무조건 잠금하고 선점
   * 비관적 락이란 트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작하는 방법이다.
   * Transaction과 Lock을 이용하여 충돌을 예방하는 것이 바로 비관적 락(Pessimistic Lock)
   * DB에서 제공해주는 특징을 이용한 Lock 방식.
   * 대표적으로 select for update문이 있다.
   * 비관적인 락은 낙관적인 락보다 데이터 일관성 문제를 해결할 수 있지만, 오버헤드가 크고 성능에 좋지 않다.
2. 낙관적 접근법
   * 트랜잭션 내에서 데이터 갱신 시 충돌이 /발생하지 않을 것으로 가정하여 별도 락을 걸지 않는 방식.
     * 락을 해야하는 상황의 발생이 일어나면 그때 대응하고, 자원을 선점 시키지 않겠다는 의미
   * version과 같은 별도의 컬럼을 추가하여, 같은 row에 대해서 각기 다른 2개의 수정 요청이 있을 때 1개가 업데이트 됨에 따라 version을 변경하여 뒤의 수정 요청을 반영하지 않는 방식.
     * 트랜잭션을 필요로하지 않는다.
   * DB에서 제공해주는 특징을 이용하는 것이 아닌 Application Level에서 잡아주는 Lock 방식.
   * 낙관적 접근법엔 Git과 같이 두 업데이트를 모두 저장한 다음 충돌이 발생했다면 표시해서 처리하는 방법도있다. 물론 병합도 수행해야한다.

<br>

💁‍♂️ **비관적, 낙관적 접근법 모두 직렬화된 요청에 의존한다. Peer-To-Peer 구조라면 일관성이 깨진다.**

즉, 단일 서버에서는 이 작업이 명확하다. 하나를 고른다음 다른 것을 고르면 되기때문.

그러나 Peer-To-Peer 복제처럼 서버가 한 대 이상이라면, 두 노드가 업데이트를 다른 순서로 적용할 수 있고, 그 결과 각 노드마다 다른 값을 가질 수 있다.

즉, **일관성이 깨지게된다.**

<br>

💁‍♂️ **물론 비관적 접근법을 사용하면 해결할 수 있다. 다만, 비관적 동시성도 문제가 많다.**

Peer-To-Peer 복제에서 쓰기 충돌을 해결하기위해 비관적 접근법을 이용하여, 모든 노드가 정상적으로 쓰기가 완료될때까지 락을 걸게할 수 있다.

다만, **이 방식은 서비스의 안정성 (쓰기 충돌을 회피)에는 좋지만, 응답성 (클라이언트에 빠르게 응답) 측면에서는 심각하게 안좋다.**

또한, 비관적 접근법은 Deadlock을 자주 초래하며, 이는 예방도 어렵고 디버깅도 어렵다.

<br>

💁‍♂️ **결국 쓰기를 단일 노드에서 처리하게하는 것이다.**

각 노드가 독립적으로 쓰기 작업을 할 수 있다면, 일관성이 깨지기 쉽다.

**가능한 단일 노드에서 쓰기를 처리하는것이, 쓰기 일관성 유지가 훨씬 쉬워진다.**

> 쓰기는 단일 노드에서만 처리되도록하는게 좋다.

<br>

# 2 읽기 일관성

<br>

## 2-1 비일관적 읽기

💁‍♂️ **비일관적 읽기** (inconsistent read)

사용자가 데이터베이스에 요청할 땐 항상 일관적인 응답을 받는다는 보장은 없다. 

즉, 읽기 일관성을 지켜주기위한 노력이 필요하다.

예를 들어, READ COMMITED 이상의 트랜잭션을 지원하지 않는 경우, 아래와 같이 COMMIT 전의 트랜잭션 데이터 변경 내용을 다른 트랜잭션이 읽음으로써 비일관적 읽기가 발생할 수 있다.

<p align="center"><img src="./image/image-20201028232334967.png"> </p>

> 만약 트랜잭션 A에서 문제가 생겨 롤백해버린다 하더라도 여전히 트랜잭션 B는 변경된 "홍길동"으로 유저를 인식하게 된다. Dirty Read가 발생한다.

<br>

💁‍♂️ **NoSQL도 한 집합에 대해서만 원자적 업데이트를 지원한다.**

NoSQL은 기본적으로 트랜잭션을 지원하지 않는다. (물론 그래프 데이터베이스는 지원한다.)

이 말은.. **여러 집합에 대해선 읽기 일관성을 기본적으로 지원하지 않는다는 의미이다.**

**물론 일반적인 집합 지향 데이터베이스는 원자적 업데이트를 한 집합에 대해선 지원한다.**

즉, **여러 집합 간의 논리적 일관성은 지원하지 않지만 한 집합 내에서는 지원된다는 의미이다.**

<br>

💁‍♂️ **비일관성 윈도**

그래서 NoSQL에서 여러 집합에 영향을 미치는 업데이트가 있는 경우 비일관적 읽기가 발생한다.

그리고 **이러한 비일관성이 존재하는 시간을 비일관성 윈도 (inconsistency window)라고 부른다.**

> AWS의 SimpleDB는 비일관성 윈도가 보통 1초 미민이라고한다. 즉, 비일관적 읽기가 발생하는 시간이 1초이내라는 의미.

<br>

💁‍♂️ **또 다른 비일관성 - 복제 일관성**

NoSQL의 트랜잭션 부재로인한 비일관적 읽기뿐 아니라 또 다른 대표적인 비일관적 읽기로 복제 일관성 (Replication) 이 있다.

Replication이다보니.. 당연히 비일관성이 발생한다. 이는 NoSQL뿐만 아니라 모든 데이터베이스에서 발생한다.

<br>

## 2-2 비일관적 읽기의 해결책

<br>

💁‍♂️ **항상 일관성을 지키는 읽기가 보장되야한다면, 일관성 수준을 높여야한다.**

비일관성 윈도가 없어야한다면, 읽기의 성능을 떨어트리더라고 일관성 수준을 높여서 처리해야한다.

<br>

💁‍♂️ **반면, 비일관성 윈도가 어느정도 존재해도된다면 Eventual Consistency (결과적 일관성)에 의존한다.**

특정 시점에는 노드에 복제나 트랜잭션으로인한 일관성 불일치가 존재할 수 있는데, 결국은 모든 노드가 같은 값으로 업데이트된다.

이를 Eventual Consistency라고 부르는데, 어느정도 비일관성 윈도를 허용해도되는 경우엔 Eventual Consistency 구조로 설계한다.

> 예를 들어, 상품 조회 같은경우 조금 업데이트가 늦더라도 빠르게 장애만 나지않으면 큰 이슈가 없다.

<br>

💁‍♂️ **세션 일관성**

Eventual Consistency이라도 자신이 쓴 것에 대한 일관성은 바로 보장되는 것이 좋다. 보장하기위해 세션 일관성 기법을 사용한다.

즉, 사용자 세션 내에서 자신이 쓴 것에 대한 일관성을 제공하는 기법이다.

> 세션이 끝나거나 다른 컴퓨터에서 접근시 사용자는 일관성을 잃을 순 있다.

세션 일관성을 보장하는 방법은 2가지 존재한다.

1. 스티키 세션 (Sticky Session)
   * 스티키 세션을 사용하면 세션을 유지하는 한 자신이 쓴 것에 대한 일관성을 보장한다. 단, 부하 부산이 제대로 되지 않을 수 있다.
2. 버전 스탬프
   * 데이터 저장소와의 모든 상호작용에 세션이 사용한 가장 최근 버전 스탬프를 포함하도록 하는 방식.
   * 이때 서버 노드는 요청에 응답하기 전에 해당 버전 스탬프가 포함된 업데이트가 반영되었음을 보장해야한다.

<br>

> 이외에도 다양한 일관성을 보장하는 방법이 존재하는데, 상황에 맞춰 해결방안을 절충안을 찾아 해결하자..

<br>

# 3 일관성 완화

💁‍♂️ **일관성을 보장할 순 있으나, 다른 특성을 포기해야한다.**

비일관성을 발생하지 않도록 설계하는 것은 가능하지만, 다른 특성을 희생해야한다.

즉, 다른 특성을 위해 일관성을 희생해야 하는 경우가 존재한다. (타협을 봐야한다.)

> 예를 들어, RDB 격리 수준을 높이면 일관성을 보장하지만, 트랜잭션으로인한 성능 저하가 계속 발생한다. 반면 DB 성능을 위해선 트랜잭션 레벨을 낮춰서 일관성을 포기해야한다.

<br>

💁‍♂️ **CAP 정리**

NoSQL에선 일관성을 완화해야하는 이유로 CAP 정리를 인용하는 경우가 많다.

**CAP는 Consistency (일관성), Availability (가용성), Partition Tolerance (분단 허용성) 세 가지 속성중 두 가지만 취할 수 있다는 정리이다.**

이와 관련된 더 자세한 내용은 [여기](https://github.com/binghe819/TIL/blob/master/DB/CAP_PACELC/CAP_PACELC_theorem.md)를 참고하자.

즉, **일관성은 비즈니스 요구사항에 따라 지킬 수도, 어느정도는 완화해서 사용해야한다.**

<br>

# 4 지속성 완화

지속성이란 트랜잭션을 완료(COMMIT)하고 완료 통지를 사용자가 받는 시점에 그 트랜잭션이 영구적이 되어 그 결과를 잃지 않는 것을 의미한다.

> 컴퓨터가 종료되거나 시스템 장애가 발생해도 계속 저장되는 성질 (RAM이 아닌 SSD에 저장된 상태)

높은 성능을 위해선 지속성도 어느정도 희생해야할 경우도 있다.

예를 들어, **데이터베이스를 대부분 메모리에서 실행할 수 있다면, 업데이트를 메모리에 적용하고 변경 사항을 주기적으로 디스크에 저장한다면, 상당히 높은 성능을 제공할 수 있게된다.** (지속성 없는 쓰기)

실제로 규모가 큰 웹 사이트의 경우 사용자의 작업을 세션에 임시 저장하고, 

예를 들어, 규모가 큰 웹 사이트의 경우 응답성과 레이턴시를 지켜야하기에 지속성을 어느정도 포기해야할 수 있다. 웹 사이트에 중요한 점은 느려터진 사이트에 대한 불만이 세션 데이터를 읽는 것보다 크리티컬하다는 것이다.

<br>

> 업데이트의 데이터를 잃어버려도 업데이트 속도가 느린것이 더 큰 문제인경우 지속성을 완화할 수 있다는 점만 기억하자.

<br>

# 5 정족수

일관성이나 지속성을 희생해야하는 경우, 양자택일을 하라는 의미는 아니다.

요청에 더 많은 노드가 관련한다면 비일관성을 회피할 확률이 더 높아진다.

예를 들어, 어떤 데이터가 세  노드에 복제되는 경우, 강력한 일관성 보장을 위해 모든 노드가 쓰기를 승인할 필요는 없다.

두 노드 정도만 승인하면 된다. 쓰기 충돌이 발생할 경우, 다수로부터 데이터를 얻으면 될 뿐이다.

이것을 정족수라고 한다.









