# Google Java Style Guide - 번역

> 이 문서는 [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)를 번역한 문서입니다. 오역이 있을 수 있습니다.

프로그래밍 공부를 하며 가장 처음 접한 스타일 가이드는 [SUN의 스타일 가이드](https://github.com/binghe819/TIL/blob/master/JAVA/%EA%B8%B0%ED%83%80/Java%20Convention.md)입니다.

이번에 운이 좋게 우테코 프리코스에 참여하게 되었는데, 요구사항으로 [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)가 있어 이 기회를 삼아 번역해보려고 합니다.

[Google java style guide](https://google.github.io/styleguide/javaguide.html)는 60% 정도는 [SUN의 스타일 가이드](https://github.com/binghe819/TIL/blob/master/JAVA/%EA%B8%B0%ED%83%80/Java%20Convention.md)와 같습니다.

몇 가지 다른 부분들은 tab 대신 space를 사용하는 것과 column limit이 80에서 100으로 더 크게 지정되었다는 부분과 최신 lambda 표기법 등이 추가 되었습니다.

<br>

## 목차

- [1 소개](#1-소개)
  * [1-1 용어 노트](#1-1-용어-노트)
  * [1-2 가이드 노트](#1-2-가이드-노트)
- [2 소스 파일의 기본](#2-소스-파일의-기본)
  * [2-1 파일 이름](#2-1-파일-이름)
  * [2-2 파일 인코딩: UTF-8](#2-2-파일-인코딩-utf-8)
  * [2-3 특수 문자](#2-3-특수-문자)
    + [2-3-1 공백 문자](#2-3-1-공백-문자)
    + [2-3-2 특수 이스케이프 문자](#2-3-2-특수-이스케이프-문자)
    + [2-3-3 Non-ASCII 문자](#2-3-3-non-ascii-문자)
- [3 소스 파일 구조](#3-소스-파일-구조)
  * [3-1 라이센스 혹은 저작권 정보 (만약 있다면)](#3-1-라이센스-혹은-저작권-정보-만약-있다면)
  * [3-2 패키지 구문](#3-2-패키지-구문)
  * [3-3 임포트 구문](#3-3-임포트-구문)
    + [3-3-1 No wildcard 임포트](#3-3-1-no-wildcard-임포트)
    + [3-3-2 No 줄바꿈](#3-3-2-no-줄바꿈)
    + [3-3-3 순서 및 간격](#3-3-3-순서-및-간격)
    + [3-3-4 클래스에는 static 임포트를 하지 않아야 합니다](#3-3-4-클래스에는-static-임포트를-하지-않아야-합니다)
  * [3-4 클래스 정의](#3-4-클래스-정의)
    + [3-4-1 정확히 하나의 최상위 클래스를 선언](#3-4-1-정확히-하나의-최상위-클래스를-선언)
    + [3-4-2 본문 내용 순서](#3-4-2-본문-내용-순서)
      - [3-4-2-1 오버로드: 절대 분리 X](#3-4-2-1-오버로드-절대-분리-x)
- [4 포매팅](#4-포매팅)
  * [4-1 중괄호](#4-1-중괄호)
    + [4-1-1 중괄호는 선택사항이라도 사용된다](#4-1-1-중괄호는-선택사항이라도-사용된다)
    + [4-1-2 비어 있지 않은 블록: K & R 스타일](#4-1-2-비어-있지-않은-블록-k---r-스타일)
    + [4-1-3 비어 있는 블럭: 아마 간결하게](#4-1-3-비어-있는-블럭-아마-간결하게)
  * [4-2 블럭 들여쓰기: +2 스페이스](#4-2-블럭-들여쓰기-2-스페이스)
  * [4-3 줄 당 하나의 서술](#4-3-줄-당-하나의-서술)
  * [4-4 열 제한: 100](#4-4-열-제한-100)
  * [4-5 줄 바꿈](#4-5-줄-바꿈)
    + [4-5-1 언제 다음 문장으로 내릴까](#4-5-1-언제-다음-문장으로-내릴까)
    + [4-5-2 들여쓰기 지속은 최소 +4 공백](#4-5-2-들여쓰기-지속은-최소-4-공백)
  * [4-6 공백](#4-6-공백)
    + [4-6-1 수직 공백](#4-6-1-수직-공백)
    + [4-6-2 수평 공백](#4-6-2-수평-공백)
    + [4-6-3 수평 정렬: 요구되지 않음](#4-6-3-수평-정렬-요구되지-않음)
  * [4-7 소괄호 그룹: 추천함](#4-7-소괄호-그룹-추천함)
  * [4-8 특별한 구조](#4-8-특별한-구조)
    + [4-8-1 Enum](#4-8-1-enum)
    + [4-8-2 변수 선언](#4-8-2-변수-선언)
      - [4-8-2-1 선언당 하나의 변수](#4-8-2-1-선언당-하나의-변수)
      - [4-8-2-2 필요할 때 선언](#4-8-2-2-필요할-때-선언)
    + [4-8-3 배열](#4-8-3-배열)
      - [4-8-3-1 배열 초기화는 "block-like"](#4-8-3-1-배열-초기화는-block-like)
      - [4-8-3-2 C언어 타입의 배열 선언은 No](#4-8-3-2-c언어-타입의-배열-선언은-no)
    + [4-8-4 Switch문](#4-8-4-switch문)
      - [4-8-4-1 들여쓰기](#4-8-4-1-들여쓰기)
      - [4-8-4-2 무산(실패): 주석](#4-8-4-2-무산실패-주석)
      - [4-8-4-3 default 케이스는 있습니다](#4-8-4-3-default-케이스는-있습니다)
    + [4-8-5 애노테이션](#4-8-5-애노테이션)
    + [4-8-6 주석](#4-8-6-주석)
      - [4-8-6-1 블럭 주석 스타일](#4-8-6-1-블럭-주석-스타일)
    + [4-8-7 접근 제한자](#4-8-7-접근-제한자)
    + [4-8-8 숫자 리터럴](#4-8-8-숫자-리터럴)
- [5 네이밍](#5-네이밍)
  * [5-1 모든 식별자에 대한 공통 규칙](#5-1-모든-식별자에-대한-공통-규칙)
  * [5-2 식별자 타입에 대한 규칙](#5-2-식별자-타입에-대한-규칙)
    + [5-2-1 패키지 명](#5-2-1-패키지-명)
    + [5-2-2 클래스 이름](#5-2-2-클래스-이름)
    + [5-2-3 함수 이름](#5-2-3-함수-이름)
    + [5-2-4 상수 이름](#5-2-4-상수-이름)
    + [5-2-5 상수가 아닌 필드의 이름](#5-2-5-상수가-아닌-필드의-이름)
    + [5-2-6 파라미터 이름](#5-2-6-파라미터-이름)
    + [5-2-7 지역 변수 이름](#5-2-7-지역-변수-이름)
    + [5-2-8 타입 변수 이름](#5-2-8-타입-변수-이름)
  * [5-3 캐멀 케이스](#5-3-캐멀-케이스)
- [6 프로그래밍 연습](#6-프로그래밍-연습)
  * [6-1 @Override: 항상 사용](#6-1-override-항상-사용)
  * [6-2 예외 잡기: 생략하지 않음](#6-2-예외-잡기-생략하지-않음)
  * [6-3 정적 멤버: 클래스를 사용할 수 있음](#6-3-정적-멤버-클래스를-사용할-수-있음)
  * [6-4 Finalizers: 사용되지 않음](#6-4-finalizers-사용되지-않음)
- [7 Javadoc](#7-javadoc)
  * [7-1 포매팅](#7-1-포매팅)
    + [7-1-1 기본 형식](#7-1-1-기본-형식)
    + [7-1-2 단락](#7-1-2-단락)
    + [7-1-3 블록 태그](#7-1-3-블록-태그)
  * [7-2 요약 조각](#7-2-요약-조각)
  * [7-3 Javadoc이 어디에 쓰이는가](#7-3-javadoc이-어디에-쓰이는가)
    + [7-3-1 예외: 자가-설명 메서드](#7-3-1-예외-자가-설명-메서드)
    + [7-3-2 예외: 오버라이드](#7-3-2-예외-오버라이드)
    + [Javadoc이 필요없는 경우](#javadoc이-필요없는-경우)
- [참고](#참고)

<br>

## 1 소개

이 문서는 Java 소스 코드에 대한 Google의 코딩 표준에 대한 완벽한 정의 문서입니다. Java 소스 파일은 여기에 있는 규칙을 준수하는 경우에만 Google 스타일로 칭할 수 있습니다.

다른 프로그래밍 스타일 가이드와 같이 다루는 문제들이 심미적(미적인) 포맷팅 주제뿐 아니라 다른 유형의 규칙이나 코딩 표준도 포함합니다. 그러나 이 문서는 주로 우리가 보편적으로 따르는 엄격하고 빠른 규칙에 초점을 맞추고 있으며, 사람이든 도구이든 명확하게 시행 할 수 없는 조언을 제공하지 않습니다.

<br>

### 1-1 용어 노트

이 문서에서는 달리 명시하지 않는 한 다음과 같이 용어를 사용합니다.

1. class라는 용어는 클래스, enum, interface, @interface를 포괄한 용어입니다.
2. 클래스의 member라는 용어는 중첩 클래스, 필드, 메서드 또는 생성자를 포괄한 용어입니다. 즉, 초기화와 주석들을 제외한 클래스의 모든 최상위 내용들을 포괄하여 쓰인다.
3. comment라는 용어는 항상 구현 주석을 가리킨다. 우리는 "documentation comments"라는 용어 대신 "Javadoc"이라는 용어를 사용합니다.

문서 전체에 다른 "용어 참고 사항"이 가끔 나옵니다.

<br>

### 1-2 가이드 노트

이 문서의 예제 코드는 비표준 (non-normative)입니다. 즉, 예제가 Google Style이지만, 스타일리쉬한 코드를 나타내지 않을 수 있습니다. 예제의 추가적인 포매팅 선택들은 규칙으로 적용되지 않아야합니다.

<br>

## 2 소스 파일의 기본

<br>

### 2-1 파일 이름

소스 파일 이름은 해당 파일이 포함하는 최상위 클래스의 대/소문자를 구분할 수 있는 이름들과 `.java` 확장자로 구성됩니다.

<br>

### 2-2 파일 인코딩: UTF-8

소스 파일은 UTF-8로 인코딩 되어 있습니다.

<br>

### 2-3 특수 문자

#### 2-3-1 공백 문자

줄을 끝내는 문자를 제외하고, ASCII horizontal space character (0x20)는 소스 파일에 나타나는 유일한 공백 문자입니다. 

이것은 다음을 의미합니다.

1. 문자열과 문자 리터럴의 다른 공백 문자는 모두 이스케이프됩니다.
2. 탭 문자는 들여 쓰기에 사용되지 않습니다.

#### 2-3-2 특수 이스케이프 문자

특수 이스케이프 문자들 (`\b`, `\t`, `\n`, `\f`, `\r`, `\"`, `\'` and `\\`)은 해당 8진수(`\012`) 또는 유니코드 (`\u000a`) 이스케이프 대신에 해당 문자가 사용됩니다.

#### 2-3-3 Non-ASCII 문자

나머지 non-ASCII 문자는 실제 유니코드 문자 (예 : `∞`) 또는 동등한 유니코드 이스케이프(`\u221e`)를 사용한다.

> 팁 : 유니코드 이스케이프의 경우, 때로는 유니코드 문자가 사용되는 경우에도 설명 주석이 매우 유용할 수 있습니다.

예시:

<p align="center"><img src="image/image-20201128234507266.png" /><br>출처 : https://google.github.io/styleguide/javaguide.html</p>

> 팁 : 일부 프로그램이 비 ASCII 문자를 제대로 처리하지 못할 수 있다는 두려움 때문에 코드의 가독성을 헤치지 마십시오. 그렇게 되면 프로그램이 망가지고 고쳐야 합니다.

<br>

## 3 소스 파일 구조

소스 파일은 다음 순서로 구성됩니다.

1. 라이센스 혹은 저작권 정보 (만약 있다면)
2. 패키지 구문
3. 임포트 구문
4. 정확히 하나의 최상위 클래스 

정확히 한 줄로 각 섹션을 구분합니다.

<br>

### 3-1 라이센스 혹은 저작권 정보 (만약 있다면)

라이센스 또는 저작권 정보가 파일에 속할 경우 여기에 속해야 한다.

<br>

### 3-2 패키지 구문

패키지 서술은 줄바꿈을 하지 않습니다. 열 제한 ([섹션 4-4, 열 제한: 100]())은 여기에 적용되지 않습니다.

<br>

### 3-3 임포트 구문

#### 3-3-1 No wildcard 임포트

static 또는 기타 와일드 카드(`*`) 임포트는 사용하지 않습니다.

#### 3-3-2 No 줄바꿈 

임포트 구문은 줄 바꿈하지 않습니다. 열 제한은 임포트 문에 적용되지 않습니다.

#### 3-3-3 순서 및 간격

임포트는 다음과 같은 단계를 따릅니다:

1. 하나의 블럭안에 static 임포트 포함
2. 하나의 블럭안에 non-static 임포트 포함

static 임포트와 non-static 임포트 모두 있는 경우, 개행을 하고 두 개의 블럭으로 나눕니다. 그 이외에는 개행이 있으면 안됩니다.

각각의 블럭에는 ASCII 순서로 정렬되어 있어야 합니다. (참고: '.'가 ';'전에 오기 때문에 임포트 구문에는 ASCII 순서가 아닙니다.)

#### 3-3-4 클래스에는 static 임포트를 하지 않아야 합니다

static 임포트는 static 중첩 클래스에 사용되지 않습니다. 그것들은 일반적인 임포트를 사용합니다.

<br>

### 3-4 클래스 정의

#### 3-4-1 정확히 하나의 최상위 클래스를 선언

각 최상위 클래스는 자체 소스 파일에 있어야합니다. (소스 파일 이름의 클래스는 최상위 클래스여야한다.)

#### 3-4-2 본문 내용 순서

클래스의 멤버 및 생성자에 대한 순서는 학습 용이성에 큰 영향을 미칠 수 있습니다. 그러나, 정답은 없습니다. 다양한 클래스들은 다른 방법으로 내용의 순서를 정할 수 있습니다.

중요한 것은 각 클래스가 어떤 논리적인 순서를 사용해야 한다는 것이며, 이는 유지보수자(혹은 관리자)가 요청하면 설명할 수 있어야 합니다. 예를 들어, 새로운 메서드를 클래스 끝에 습관적으로 추가했다면, 이는 논리적 순서가 아닌 "발생 순서대로"추가한 것입니다. (이는 잘못된 예제)

##### 3-4-2-1 오버로드: 절대 분리 X

클래스가 여러 개의 생성자들 혹은 같은 이름의 함수들을 가지고 있다면 이것들은 가운데 다른 코드들 없이 차례로 나타나야 합니다. (private 멤버라 할 지라도)



## 4 포매팅

용어 노트 : block-like construct (블록과 유사한 구조)는 클래스, 메서드 또는 생성자의 본문을 나타냅니다. []()에 따라 모든 배열 초기화블럭은 block-like construct인 것처럼 처리될 수 있습니다.

<br>

### 4-1 중괄호

> 중괄호 = `{}`

#### 4-1-1 중괄호는 선택사항이라도 사용된다

중괄호는 본문이 비어 있거나 단일문이라도 사용됩니다. 

즉, if, else, for, do, while 구문에 몸체가 없거나 한 줄만 있어도 중괄호가 사용되야 합니다.

#### 4-1-2 비어 있지 않은 블록: K & R 스타일

중괄호는 비어 있지 않은 블럭(non-empty)과 block-like construct에 대해서 Kernighan과 Ritchie 스타일(Egyptian brackets)을 따릅니다.

* 여는 중괄호 앞에는 줄 바꿈이 없음.
* 여는 중괄호 뒤의 줄 바꿈.
* 닫는 중괄호 전에 줄 바꿈
* 명령문, 메서드, 생성자 또는 클래스의 본문이 끝났을 때는 닫는 중괄호 다음에 줄 바꿈. 만약 else나 콤마뒤에 나오는 부분일 경우 줄 바꿈 하지 않음.

예시:

```java
return () -> {
  while (condition()) {
    method();
  }
};

return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    } else if (otherCondition()) {
      somethingElse();
    } else {
      lastThing();
    }
  }
};
```

Enum 클래스는 예외가 있습니다. [4.8.1]()

#### 4-1-3 비어 있는 블럭: 아마 간결하게

빈 블럭이나 block-like construct 에서는 K & R 스타일 일 수 있습니다 ([4.1.2](#4-1-2-비어-있지-않은-블록-k--R-스타일) 처럼). 대안으로 중괄호 안에 문자가 없거나 줄바꿈이라면 열자마자 닫을 수 있습니다. 하지만 멀티 블럭 구문에서는 안됩니다. (직접 멀티 블럭을 가진: `if/else`, `try/catch/finally` 등)

예시:

```java
  // 허용됩니다.
  void doNothing() {}

  // 이것도 허용됩니다.
  void doNothingElse() {
  }
```

```java
  // 허용되지 않음: 멀티 블럭 구문에서는 간결한 빈 블럭을 사용할 수 없습니다.
  try {
    doSomething();
  } catch (Exception e) {}
```

<br>

### 4-2 블럭 들여쓰기: +2 스페이스

새 블럭 또는 block-like constructor가 열릴 때마다 두 칸씩 들여쓰기합니다. 블럭이 끝나면, 들여쓰기는 이전의 들여쓰기 단계로 돌아갑니다. 들여쓰기 단계는 코드와 주석에 모두 적용됩니다. ([4.1.2](#4-1-2-비어-있지-않은-블록-k--R-스타일) 예제 코드를 참고하세요.)

<br>

### 4-3 줄 당 하나의 서술

각각의 구문은 뒤에 줄바꿈이 있습니다.

<br>

### 4-4 열 제한: 100

자바 코드는 100 문자의 열 제한이 있습니다. 여기서 "문자"란 어떠한 유니코드 포인트를 말합니다. 아래 명시된 경우를 제외하고는 제한을 초과하는 모든 줄은 [섹션 4.5]()에서 설명한대로 줄 바꿈해야 합니다.

> 하나의 유니코드 포인트는 화면상 표시 넓이가 길든 짧든 하나의 문자로 계산됩니다. 예를 들어, full-width (한국어, 중국어 등등)를 사용할 경우 규칙보다 일찍 줄 바꿈하는게 좋습니다.

예외:

1. 열 제한을 따를 수 없는 행 (예 : Javadoc의 긴 URL 또는 긴 JSNI 메서드 참조)
2. package나 import 구문 ([3.2 패키지 구문](#3-2-패키지-구문), [3.3 임포트 구문](3-3-임포트-구문) 참조)
3. 쉘에 복사 붙여넣기 되는 명령 줄에 대한 주석

<br>

### 4-5 줄 바꿈

용어 노트 : 코드가 하나의 줄에서 여러 줄로 바뀐다면 그것을 줄 바꿈이라고 부릅니다.

모든 상황에서 줄 바꿈하는 방법을 정확히 보여주는 포괄적이고 결정적인 공식은 없습니다. 동일한 코드를 줄 바꿈하는 여러 가지 유효한 방법이 있습니다. (절대적인 법칙은 없고 상황에 맞게 적절하게 사용하면 됩니다.)

> 노트 : 줄 바꿈의 일반적인 이유는 열 제한을 넘지 않기 위함이지만, 열 제한에 걸리지 않는 코드도 작성자의 재량에 따라 줄 바꿈 할 수 있습니다.

> 팁 : 메서드 또는 지역 변수를 추출하는 것이 줄 바꿈을 대신할 수 있는 방법이 될 수 있습니다.

#### 4-5-1 언제 다음 문장으로 내릴까

줄 바꿈의 주요 원칙은 더 높은 구문 수준에서 바꾸는 것입니다. 또한:

1. non-assignment 연산자에서 줄 바꿈이 일어난 경우 줄 바꿈은 기호 이전에 위치합니다.
   * 이것은 "operator-like" 기호에도 적용됩니다.
     * the dot separator (`.`)
     * 2개 콜론 (`::`)
     * 타입 바운딩의 앰퍼센드 기호 (`<T extends Foo & Bar>`)
     * catch 블럭의 파이프 (` catch (FooException | BarException e)`)

2. assignment 연산자에서 줄 바꿈이 일어나면 기호 다음에 바뀌지만 어디서 바뀌어도 상관없습니다.
   * 이것은 "assignment-operator-like"콜론에도 적용됩니다. (`foreach`)
3. 메서드나 생성자의 이름에 여는 괄호가 있을 때 
4. 콤마 앞에 오는 토큰에 연결되어 있을 때
5. 줄은 람다식의 인접한 화살표에서는 바뀌지 않는다. 하지만 람다의 몸체가 한 줄로 되어 있다면 바꿔도 됩니다. 예를 들면:

```java
MyLambda<String, Long, Object> lambda = 
    (String label, Long value, Object obj) -> {
        ...
    };

Predicate<String> predicate = str ->
    longExpressionInvolving(str);
```

> 참고 : 줄 바꿈의 목적은 깨끗한 코드를 만들기 위함이지, 줄 수를 줄이는데 있지 않습니다.

<br>

예시:

```java
String someThing = new StringBuffer()
          .append("hello")
          .append("world");

String someThing = "hello"
                 + "world";
```

#### 4-5-2 들여쓰기 지속은 최소 +4 공백

줄 바꿈할 때, 각 줄은 원래 줄보다 +4 스페이스만큼 들여쓰기를 해야합니다.

여러 줄 바꿈 줄이 있을 때, 들여쓰기는 +4 이상으로 변동 가능합니다. 일반적으로, 두 개의 연속된 줄은 같은 들여쓰기 레벨을 갖고 구문적으로 병렬인 요소일때만 적용됩니다.

[4.6.3]()에 수평 일직선은 가변적인 수의 공백을 사용하여 특정 토큰을 이전 행과 정렬하는 불편함을 언급합니다.

<br>

### 4-6 공백

#### 4-6-1 수직 공백

> 수직 공백이란 하나의 줄을 공백으로 두는 것을 의미한다.

하나의 공백 줄은 항상 아래와 같을 때 사용합니다:

1. 연속 멤버 또는 클래스의 초기화: 필드, 생성자, 메서드, 중첩 클래스, 정적 초기화 그리고 인스턴스 초기화
   * 예외: 연속된 두 필드 사이의 공백은 선택입니다. 이러한 공백은 필요에 따라 필드의 논리적 그룹을 만드는데 사용됩니다.
   * 예외: enum 상수의 공백 줄은 [4.8.1]() 절에서 다룹니다.
2. 이 문서의 다른 섹션에서도 필요합니다. ([섹션 3 소스 파일 구조](), 그리고 [3.3 임포트 구문]())

하나의 공백 줄은 가독성을 향상시킬 수 있는 어디에서나 등장할 수 있습니다. 예를 들어, 코드를 논리적 부분으로 나눌 때 사용됩니다. 첫번째 멤버나 초기화 전의 공백 줄 혹은 클래스의 마지막 멤버나 초기화 뒤에 오는 공백 줄은 권장되거나 권장되지 않습니다.

여러 개의 연속된 공백은 허용되지만 요구되지는 않습니다.

#### 4-6-2 수평 공백

리터럴, 주석 및 Javadoc을 제외하고 언어 또는 기타 스타일 규칙이 필요한 곳을 넘어서는 경우 단일 ASCII 공간은 다음 위치에만 나타납니다

1. 예약어를 분리하는 경우, `if`, `for`, `catch` 같은 예약어 이후 나오는 여는 괄호(`(`)에서 사용
   * ex) `if (...)`, `for (...)`, `catch (...)`
2. 예약어를 분리하는 경우, `else`, `catch` 같은 예약어 이후 나오는 닫는 중괄호(`}`)에서 사용
   * ex) `} else {`, `} catch {`
3. 중괄호(`{`) 열기 전 모든 경우에 사용, 다음 두 가지 예외 :
   * `@SomeAnnotation({a, b})`
   * `String[][] x = {{"foo"}};`
4. 이항 또는 삼항 연산자의 양쪽에 사용. 이것은 "operator-like" 기호에도 적용됩니다.
   * 인접한 타입 바인딩의 앰퍼센드 연산자(`&`)에서 : `<T extends Foo & Bar>`
   * 여러 예외를 처리하는 catch 블록의 파이프에서 : `catch (FooException | BarException e)`
   * 향상된 `for`(foreach)문에서 
   * 화살표 람다 표현식에서 : `(String str) -> str.length()`
   * 하지만, 두 개의 `::` 콜론에서는 띄우면 안됩니다. `Object::toString`
   * 그리고 dot(`.`) 연산자에서도 띄우면 안됩니다. `object.toString()`
5. `,:;` 혹은 캐스팅 할 때 닫는 괄호(`)`) 뒤에서 사용.
   * `Parent child = (Parent) childObject`
6. `//` 더블 슬래시에서 양쪽에 사용. 여러 수의 공백이 허용되지만 필수사항은 아님.
7. 타입과 변수의 선언 사이에. `List<String> list`
8. 배열 선언문 사이의 공백은 선택사항
   * `new int[] {5, 6}` 와 `new int[] { 5, 6 }` 모두 가능.
9. 타입 애노테이션과 `[]`이나 `...`사이에 사용. 

이 규칙은 라인의 시작 또는 끝에 추가 공백을 요구하거나 금지하는 것은 아닙니다. 이 규칙들은 오직 내부 공간만을 다룹니다.

<br>

#### 4-6-3 수평 정렬: 요구되지 않음

용어 노트 : 수평 정렬은 특정 토큰이 이전 줄의 다른 특정 토큰 바로 아래에 표시되도록 코드에 다양한 수의 추가 공백을 추가하는 방법입니다.

이것은 허용되지만 Google Style에서는 필수사항이 아닙니다. 심지어 이미 쓰고있는 사황에서도 수평 맞춤을 유지하는게 필수가 아니라고 말합니다.

```java
private int x; // 괜찮음
private Color color; // 이것도 괜찮음

private int   x;     // 허용, 하지만 나중에 고쳐야함.
private Color color; // 맞춰지지 않은 상태로 둘 수도 있다.
```

> 팁 : 정렬은 가독성을 높여줍니다. 하지만 추후의 유지보수에 문제를 일으킵니다. 나중에 한 줄만 수정한다고 가정해보면, 이 변경으로 인해 이전에 맞춰놓은 서식이 엉망으로 남을 수 있습니다. 허용은 됩니다. 제작자에게 수정하는 것을 촉구하며, 일련의 재포매팅을 유발할 수도 있습니다. 그 한줄짜리 변경은 이제 "폭발 반경"을 갖습니다. 이것은 최악의 경우 혼잡하지 않은 상황이 될 수 있지만, 근본적으로 버전 히스토리 정보가 손상되고 검토자를 느리게하고 머지 충돌이 일어납니다.

<br>

### 4-7 소괄호 그룹: 추천함

선택적 그룹 괄호는 작성자와 검토자가 코드가 없으면 잘못 해석 될 가능성이 없으며 코드를 읽기 쉽게 만든다는 데 동의하지 않는 경우에만 생략됩니다. 모든 독자가 연산자 우선 순위 테이블을 가지고 있다고 가정하는 것은 비합리적입니다. 우선순위 연산자가 명확하더라도 소괄호로 감싸는 것을 추천합니다.

<br>

### 4-8 특별한 구조

<br>

#### 4-8-1 Enum

Enum 상수에 따라오는 콤마 뒤의 줄바꿈은 선택 사항입니다. 추가 빈줄 (일반적으로 하나만)도 허용됩니다. 

```java
private enum Anser {
  YES {
    @Override public String toString() {
      return "yes";
    }
  },
  
  NO,
  MAYBE
}
```

메서드나 도큐먼트가 없는 Enum 클래스는 배열 초기화와 같은 포맷으로 작성될 수 있습니다. ([4.8.3.1 배열 초기화 참조]())

```java
private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }
```

Enum 클래스는 클래스이므로 클래스 포맷팅 형식이 적용됩니다.

<br>

#### 4-8-2 변수 선언

##### 4-8-2-1 선언당 하나의 변수

매 변수 초기화는 하나의 변수만 초기화 합니다: `int a, b;`와 같은 선언은 안씁니다.

예외: for 루프의 헤더에는 여러 변수 선언을 씁니다.

<br>

##### 4-8-2-2 필요할 때 선언

지역 변수는 block-like construct가 시작될 때 습관적으로 쓰일 필요가 없습니다. 대신, 지역 변수는 범위를 좁히기 위해 그것들이 처음 사용될 때 가까운 위치에 선언합니다. (이유가 있어야 합니다.) 지역 변수는 전형적으로 초기화(생성자)를 시키거나 선언과 동시에 초기화를 시킵니다.

<br>

#### 4-8-3 배열

##### 4-8-3-1 배열 초기화는 "block-like"

배열 초기화는 "block-like construct"처럼 포매팅 될 수 있습니다. 

```java
new int[] {           new int[] {
  0, 1, 2, 3            0,
}                       1,
                        2,
new int[] {             3,
  0, 1,               }
  2, 3
}                     new int[]
                          {0, 1, 2, 3}
```

<br>

##### 4-8-3-2 C언어 타입의 배열 선언은 No

대괄호는 타입에 붙어야 합니다. 변수에 붙으면 안됩니다. `String[] args`가 맞고, `String args[]`가 틀림

<br>

#### 4-8-4 Switch문

용어 노트 : Switch문의 중괄호안에는 한개 혹은 여러개의 구문 그룹들이 존재합니다. 각각의 그룹은 구문 이전에 한개 이상의 switch 라벨이 붙습니다. `case`혹은 `default`

##### 4-8-4-1 들여쓰기

다른 블록처럼 switch 블럭의 들여쓰기는 +2 입니다.

switch 라벨 뒤에 개행이 오고, 들여쓰기 레벨은 정확히 블럭이 열렸을 때와 같이 +2 증가합니다. 그 다음에 오는 switch 라벨은 블럭이 닫힌 것처럼 이전의 들여쓰기 레벨과 같이합니다.

<br>

##### 4-8-4-2 무산(실패): 주석

switch 블럭 안의 각 구문들은 갑자기 종료될 수 있습니다. (`break`, `continue`, `return` 혹은 예외) 혹은 다음 구문으로 실행이 넘어가는 것을 표시할 수 있습니다. 이 불발 상황에 대해 주석을 달 수 있습니다. (`// fall through`) 이 특별한 주석은 switch문의 마지막 구문에는 올 필요가 없습니다.

```java
switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
    // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
```

`case 1:` 뒤에는 주석이 필요 없습니다. 오직 구문의 마지막에 있으면 됩니다.

<br>

##### 4-8-4-3 default 케이스는 있습니다

각 switch 구문은 `default` 그룹을 포함합니다. 그 그룹에 코드가 없을지라도 포함합니다.

예외: enum 타입의 switch 구문은 다른 모든 경우의 처리를 다 했다면 `default`를 생략 가능합니다. 이것은 IDE나 다른 정적 분석 툴이 누락된 사례가 있는 경우 경고를 해줍니다.

<br>

#### 4-8-5 애노테이션

애노테이션은 documentation 블록 바로 이후에 클래스나 함수 혹은 생성자에 적용됩니다. 그리고 각 애노테이션들은 그들 만의 줄을 가지고 있습니다. (한 줄에 하나의 애노테이션) 이러한 개행은 줄바꿈에 해당되지 않습니다. 그래서 들여쓰기 레벨이 증가되지 않습니다.

```java
@Override
@Nullable
public String getNameIfPresent() {...}
```

예외 : 파라미터가 없는 단일 애노테이션은 한줄에 쓸 수 있습니다.

```java
@Override public int hashCode() {...}
```

필드에 적용되는 애노테이션들은 한 줄에 쓸 수 있습니다. (파라미터가 있어도 됩니다.)

```java
@Partial @Mock DataLoader loader;
```

파라미터나 지역변수 혹은 타입에 적용되는 애노테이션의 특정한 포맷팅 규칙은 없습니다.

<br>

#### 4-8-6 주석

이 섹션은 구현 주석에 대한 내용입니다. [Javadoc]()은 섹션 7에서 위치합니다.

아무 줄 바꿈 앞에는 임의의 공백 문자와 그 뒤에 구현 주석이 올 수 있습니다. 이러한 주석은 행을 비어 있지 않게 만듭니다.

##### 4-8-6-1 블럭 주석 스타일

블럭 주석 스타일은 둘러  쌓인 코드와 같은 들여쓰기 레벨을 가집니다. `/* ... */` 나 `// ...` 같은 스타일 입니다. 멀티 라인 `/* ... */` 주석은 뒤어이 오는 줄은 *로 시작해야 하는데 그 이전 *과 맞아야 합니다.

```java
/*
 * This is          // And so           /* Or you can
 * okay.            // is this.          * even do this. */
 */
```

주석은 별표 또는 기타 문자로 그려진 박스에 넣지 않습니다.

> 팁 : 여러 줄의 주석을 작성할 때 문단 형식으로 re-wrap을 하고 싶으면 `/* ... */`의 형식으로 작성합니다. 대부분 포매터들은 `// ...`의 re-wrap을 지원하지 않습니다.

<br>

#### 4-8-7 접근 제한자

클래스 및 멤버 수정자가 있는 경우 Java 언어 사양에서 권장하는 순서로 나타냅니다.

```java
public protected private abstract default static final transient volatile synchronized native strictfp
```

<br>

#### 4-8-8 숫자 리터럴

long의 값을 가지는 정수 리터럴은 대문자 L의 접미사를 가집니다. (소문자가 아닌 이유는 숫자 1과 헷갈리기 때문입니다.) 예를 들어 3000000000L을 3000000000l 대신에 씁니다.

<br>

## 5 네이밍

<br>

### 5-1 모든 식별자에 대한 공통 규칙

식별자는 오직 ASCII와 숫자만 사용해야 합니다. 극히 일부의 경우 밑줄(`_`)로 표시합니다. 그러므로 유효한 식별자 이름은 정규식 `\w+`와 매칭됩니다.

구글 스타일에는 특별한 접미사(prefix)나 접두사(suffixes)를 쓰지 않습니다. 즉 다음과 같은 형태의 식별자는 사용되지 않습니다: `name_`, `mName`, `s_name`, `kName`.

<br>

### 5-2 식별자 타입에 대한 규칙

#### 5-2-1 패키지 명

모두 소문자로 기술합니다. 단어가 달라지더라도 무조건 소문자를 사용합니다.

* `com.example.deepspace` (o)
* `com.example.deepSpace` (x)
* `com.example.deep_space` (x)

<br>

#### 5-2-2 클래스 이름

클래스 이름은 UpperCamelCase 입니다.

클래스 이름은 전형적으로 명사나 명사구입니다. 예를 들어, `Character` 혹은 `ImmutableList`. 인터페이스의 이름은 명사나 명사구가 될 수 있습니다. 예를 들어 `List`. 그러나 가끔은 형용사나 형용사구가 대신 쓰이기도 합니다. (예를 들어 `Readable`)

애노테이션 타입에 대한 잘 만들어진 규칙같은 것은 없습니다.

테스트 클래스들은 테스트하고자하는 클래스의 이름이 앞에오고 끝에 `Test`를 붙여줍니다. 예를 들어 `HashIntegrationTest`

<br>

#### 5-2-3 함수 이름

함수 이름은 lowerCamelCase입니다.

함수 이름은 전형적으로 동사 혹은 동사구입니다. 예를 들어, `sendMessage` 혹은 `stop`입니다. 

언더스코어는 JUnit 테스트에서 논리적 컴포넌트를 분리시키기 위해 각각의 lowerCamelCase로 변경시켜 나올 수 있습니다. 하나의 전형적인 패턴은 `<테스트할 메서드>_<상태>` 입니다. 예를 덜어 `pop_emptyStack`. 테스트 메서드 이름엔 정답이 없습니다.

<br>

#### 5-2-4 상수 이름

상수는 CONSTANT_CASE를 사용합니다. 모두 대문자이며 각 단어는 하나의 언더스코어로 구분하는 형식입니다. 하지만 상수가 정확히 무엇일까요?

상수는 `static final` 필드인데 그것은 변경될 수 없고 그것들의 메서드는 부작용이 보여서는 안됩니다. 이것은 원시타입, 문자열 그리고 불변 타입, 불변 타입의 불변 컬렉션을 포함합니다. 만약 어떤 인스턴스의 상태가 바뀐다면 그것은 상수가 아닙니다. 단지 객체의 상태를 변화시키지 않는 것이 목적은 아닙니다. 예를 들어:

```java
// Constants
static final int NUMBER = 5;
static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");
static final ImmutableMap<String, Integer> AGES = ImmutableMap.of("Ed", 35, "Ann", 32);
static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutable
static final SomeMutableType[] EMPTY_ARRAY = {};
enum SomeEnum { ENUM_CONSTANT }

// Not constants
static String nonFinal = "non-final";
final String nonStatic = "non-static";
static final Set<String> mutableCollection = new HashSet<String>();
static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);
static final ImmutableMap<String, SomeMutableType> mutableValues =
    ImmutableMap.of("Ed", mutableInstance, "Ann", mutableInstance2);
static final Logger logger = Logger.getLogger(MyClass.getName());
static final String[] nonEmptyArray = {"these", "can", "change"};
```

이 이름들은 전형적인 명사나 명사구입니다.

<br>

#### 5-2-5 상수가 아닌 필드의 이름

상수가 아닌 필드 이름은 (`static`같은) lowerCamelCase로 작성합니다.

이러한 이름들은 전형적으로 명사나 명사구입니다. 예를 들어, `computedValues` 혹은 `index`.

<br>

#### 5-2-6 파라미터 이름

파라미터 이름은 lowerCamelCase로 작성합니다.

`public` 메서드에서 한 개의 문자를 가진 파라미터명는 피해야 합니다.

<br>

#### 5-2-7 지역 변수 이름

로컬 변수 이름은 lowerCamelCase로 작성합니다.

심지어 `final` 이나 불변, 지역변수는 상수로 간주되어서는 안되고 상수 스타일로 기술해서도 안됩니다.

<br>

#### 5-2-8 타입 변수 이름

각 타입들은 두 스타일중 하나를 따릅니다.

* 하나의 대문자, 혹은 뒤에 하나의 숫자가 따라올 수 있습니다. (`E`, `T`, `X`, `T2`)
* 클래스를 위해서 사용되는 이름의 형식에 `T` 대문자가 따라오는 형식 (`RequestT`, `FooBarT`)

<br>

### 5-3 캐멀 케이스

| Prose form              | Correct                                                      | Incorrect           |
| ----------------------- | ------------------------------------------------------------ | ------------------- |
| "XML HTTP request"      | `XmlHttpRequest`                                             | `XMLHTTPRequest`    |
| "new customer ID"       | `newCustomerId`                                              | `newCustomerID`     |
| "inner stopwatch"       | `innerStopwatch`                                             | `innerStopWatch`    |
| "supports IPv6 on iOS?" | `supportsIpv6OnIos`                                          | `supportsIPv6OnIOS` |
| "YouTube importer"      | `YouTubeImporter` (권장)<br>`YoutubeImporter` (권장하지 않음) |                     |

1. 우선 ASCII 문자로 모두 바꾼다. [‘ “ `] 등의 문자를 제거한다.
2. 단어로 구별해서 단어 사이에 스페이스를 하나 둔다.
3. 각 단어의 첫 문자 외에는 모두 소문자로 바꾼다.
4. 단어들을 모두 합친다. (스페이스 제거)

<br>

## 6 프로그래밍 연습

### 6-1 @Override: 항상 사용

메서드가 오버라이딩을 하면 @Override 애노테이션을 마크해줍니다. 이것은 상위 클래스를 오버라이딩하는 클래스 메서드, 인터페이스 메서드를 구현하는 클래스 메서드, 상위 인터페이스의 메서드를 재구현하는 인터페이스 메서드 모두 포함입니다.

예외: 부모 메서드가 @Deprecated된 경우, @Override를 생략할 수 있습니다.

<br>

### 6-2 예외 잡기: 생략하지 않음

아래 명시되있는 것말고 예외를 잡고 아무것도 안하는 것은 거의 있을 수 없습니다. (전형적인 반응은 로그를 남기는 것 혹은 불가능하다고 간주되면 AssertionError로 다시 던져줍니다.)

캐치 블록에서 아무것도 하지 않는 것이 정당하다면 주석을 남기는 것으로 정당화합니다.

```java
try {
    int i = Integer.parseInt(response);
    return handleNumericResponse(i);
} catch (NumberFormatException ok) {
    // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
```

예외: 테스트에서 예외를 잡는 부분은 expected, 혹은 expected로 시작하는 이름을 지으면서 무시할 수 있습니다. 다음 예제는 테스트에서 예외가 나오는게 확실한 상황에서 사용되는 대중적인 형식으로 주석이 필요없습니다.

```java
try {
    emptyStack.pop();
    fail();
} catch (NoSuchElementException expected) {
}
```

<br>

### 6-3 정적 멤버: 클래스를 사용할 수 있음

static 클래스 멤버 참조는 그에 대한 자격이 있어야 하는데 그것은 클래스 타입이 아니라 이름입니다.

```java
Foo aFoo = ...;
Foo.aStaticMethod(); // good
aFoo.aStaticMethod(); // bad
somethingThatYieldsAFoo().aStaticMethod(); // very good
```

<br>

### 6-4 Finalizers: 사용되지 않음

`Object.finalize`를 재정의하는 것은 극히 드뭅니다.

> 팁: 그냥 사용하지 마세요. 자세한 내용은 이펙티브 자바 아이템 7을 보면 됩니다.

<br>

## 7 Javadoc

### 7-1 포매팅

#### 7-1-1 기본 형식

Javadoc 볼륵의 기본 형식은 다음 예제와 같습니다.

```java
/**
 * Multiple lines of Javadoc text are written here,
 * wrapped normally...
 */
public int method(String p1) { ... }
```

혹은 다음과 같이 한 줄에 사용됩니다.

```java
/** An especially short bit of Javadoc. */
```

기본 형식은 항상 허용됩니다. Javadoc 블록 전체가 한 줄에 들어갈 수 있는 경우엔 한 줄 형식으로 사용가능합니다. 이것은 `@return`과 같은 블록 태그가 없는 경우에만 해당됩니다.

<br>

#### 7-1-2 단락

한 개의 빈줄 (나타나는 선행 별표(`*`)만 포함하는 행)은 단락 사이에, 그리고 블록 태그 그룹 앞에 표시됩니다. 첫 번째 단락을 제외한 각 단락에는 첫 번째 단어 바로 앞에 `<p>`가 있으며 뒤에 공백은 없습니다.

<br>

#### 7-1-3 블록 태그

표준 블록 태그는 `@param`,  `@return`, `@throws`, `@deprecated`로 나타내지는데 이 네 가지의 타입은 빈 서술이 있으면 안됩니다. 블럭 태그가 한 줄에 입력이 되지 않는다면 다음 줄은 @위치에서 들여쓰기를 4번 합니다.

<br>

### 7-2 요약 조각

각 Javadoc 블록은 간단한 요약 부분으로 시작됩니다. 이 부분은 매우 중요합니다. 클래스 및 메서드 인덱스와 같은 특정 컨텍스트에 나타나는 텍스트의 유일한 부분입니다. 

이것은 완전한 문장이 아니라 명사구 또는 동사구입니다. `A {@code Foo} is a...`나 `This method returns`로 시작하지 않고, 또한 `Save the record`과 같은 완전한 명령형을 구성하지도 않습니다. 그러나 완전한 문장 인 것처럼 대문자로 표시되고 구두점으로 표시됩니다.

> 팁 : 일반적인 실수는 `@return the customer ID` 형식으로 간단한 Javadoc을 작성하는 것입니다. 이것은 올바르지 않으며 `Returns the customer ID`로 변경해야 합니다.

<br>

### 7-3 Javadoc이 어디에 쓰이는가

최소한 Javadoc은 매 public class에 쓰이고 그러한 클래스 안에 public, protected 멤버에 쓰입니다. 몇몇의 예외는 아래와 같습니다.

추가 Javadoc 본문은 있을 수 있습니다.

<br>

#### 7-3-1 예외: 자가-설명 메서드

Javadoc은 간단하고 명료한 메서드(예를 들어 `getFoo()`)의 경우 선택적으로 사용됩니다. 이 경우 foo를 반환한다 이외에는 도저히 설명할 길이 없는 경우입니다.

중요: 그렇다고 해서 독자가 알아야할 정보를 빠트리는 것은 안됩니다. 예를들어 `getCanonicalName`의 경우 문서화를 빠트리지 말아야합니다. 왜냐하면 일반적인 독자는 canonical name이 무슨 뜻인지 모르기 때문입니다.

<br>

#### 7-3-2 예외: 오버라이드

Javadoc은 슈퍼 타입 메서드를 오버라이드를 한다면 항상 존재하지는 않습니다.

<br>

#### Javadoc이 필요없는 경우

다른 클래스 및 멤버는 필요에 따라 또는 원하는대로 Javadoc을 가집니다.

구현 주석이 클래스 또는 멤버의 전반적인 용도 또는 동작을 정의하는 데 사용될 때마다 해당 주석은 대신 Javadoc으로 작성되야 합니다. (`/**`을 사용합니다.)

불필요한 Javadoc은 7.1.2, 7.1.3, 7.2의 포맷 규칙을 엄격히 준수할 것을 요구하지는 않지만, 권장합니다.

<br>

## 참고

* https://brunch.co.kr/@daniellim/22
* https://github.com/JunHoPark93/google-java-styleguide