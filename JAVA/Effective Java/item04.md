> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

단순히 static 메서드와 static 필드를 모아둔 클래스를 만드는 경우가 존재한다. (`java.lang.Math`, `java.util.Arrays`등)

그리고 static 멤버만 담은 유틸리스성 클래스는 인스턴스를 만들어 쓰려고 설계하는 것이 아니다.

그러므로 **유틸성으로 사용하는 클래스들의 인스턴스화를 막으려면 명시적 생성자에 private를 사용해야 한다.**

만약, **생성자에 아무것도 명시하지 않는다면 컴파일러가 자동적으로 public 생성자를 만들기 때문에 꼭! 명시적으로 private를 사용해줘야 한다.**

```java
// 인스턴스화를 하지 않는 유틸성 클래스
public class UtilityClass {
  // 기본 생성자가 만들어지는 것을 막는다. (인스턴스화 방지용)
  private UtilityClass {
    throw new AssertionError(); // 내부에서 접근하여 인스턴스화하는 것을 방지하기 위한 예외처리.
  }
}
```

부가적으로 이 방식은 상속을 불가능하게 하는 효과도 있다. 상속한 경우에 명시적이든 암묵적이든 상위 클래스의 생성자를 호출해야 하는데, 이 클래스의 생성자가 private이라 호출이 막혔기 때문에 상속을 할 수 없다.

**결론 : 인스턴스화를 막고 상속도 못하게하려거든 꼭 생성자에 private을 붙여주자**

> **많은 오픈소스에서 abstract class를 이용해 인스턴스화를 막기도 한다.**

