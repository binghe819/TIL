> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라

가변인수 (`varargs`) 메서드와 제네릭을 같이 사용하면 문제가 발생하기 때문에 신중하게 사용해야 한다.

<br>

- [아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라](#아이템-32-제네릭과-가변인수를-함께-쓸-때는-신중하라)
  - [1 가변인수의 허점](#1-가변인수의-허점)
  - [2 제네릭 가변인수 혼용](#2-제네릭-가변인수-혼용)
    - [2-1 타입 안정성이 깨진다](#2-1-타입-안정성이-깨진다)
    - [2-2 안전하지 않지만 허용한다](#2-2-안전하지-않지만-허용한다)
  - [3 @SafeVarargs](#3-safevarargs)
    - [3-1 @SafeVarargs란](#3-1-safevarargs란)
    - [3-2 메서드가 안전한지 어떻게 확신하는가](#3-2-메서드가-안전한지-어떻게-확신하는가)
      - [예시](#예시)
  - [핵심 정리](#핵심-정리)

<br>

## 1 가변인수의 허점
* 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, **구현 방식에 허점이 존재한다.**
* 가변인수 메서드를 호출할 경우, 가변인수를 담기 위한 배열이 자동으로 하나 생성된다.
  * **내부로 감춰야하는 이 배열을 클라이언트에 노출하는 문제가 생긴다.**
    * 배열을 만들어서 바로 return하게 되면 문제가 발생하기 때문.
  * **가변인수 제네릭이나 매개변수화 타입이 포함될 경우 알기 어려운 컴파일 경고가 발생하게 된다.**
* 힙 오염
  * 매개변수화 타입의 변수가 타입이 다른 객체를 참조할 경우 힙 오염이 발생할 가능성이 있다.

<br>

## 2 제네릭 가변인수 혼용
> 제네릭과 가변인수를 혼용하면 문제가 발생한다. 하지만 허용된다.

<br>

### 2-1 타입 안정성이 깨진다

제네릭타입의 가변인수 메서드를 호출하면, 제네릭 타입의 배열이 생성되며, 

**제네릭 타입의 배열은 실체화가 불가능하고, 타입을 런타임에 체크하기 때문에 `ClassCastException`가 날 가능성이 있다.**

```java
static void dangerous(List<String>... stringLists) {
    List<Integer> intList = List.of(42);
    Object[] objects = stringLists;
    objects[0] = intList;              // 힙 오염 발생
    String s = stringLists[0].get(0);  // ClassCastException
}
```
* **제네릭과 가변인수를 혼용하면 타입 안정성이 깨진다.**
  * 따라서 제네릭 가변인수 배열 매개변수에 값을 저장하는 것은 안전하지 않다.

<br>

### 2-2 안전하지 않지만 허용한다
제네릭과 가변인수를 혼용하는 것은 타입 안정성의 문제가 발생시키지만, 허용된다.

**그 이유는 제네릭이나 매개변수화 타입의 가변인수 매개변수를 받는 메서드가 실무에서 매우 유용하기 때문이다.**

* `Arrays.asList(T... a)`
* `Collections.addAll(Collection<? super T> c, T... elements)`
* ...

<br>

## 3 @SafeVarargs
제네릭과 가변인수의 혼용을 허용하지만, 여전히 타입 안정성의 문제가 있다.

이로 인해 컴파일러는 경고를 내보낸다. 이를 숨기는 방법으로 `@SafeVarargs`가 쓰인다.

```java
// Arrays.Java
@SafeVarargs
@SuppressWarnings("varargs")
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
```

<br>

### 3-1 @SafeVarargs란
* `@SafeVarargs`
  * **메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치**
  * 안전한게 확실하지 않으면 절대 사용하면 안된다.

<br>

### 3-2 메서드가 안전한지 어떻게 확신하는가
> 순수하게 인수들을 전달하는 일만 할 때 메서드가 안전하다.
* 메서드가 `varargs` 매개변수 배열에 아무것도 저장하지 않아야 한다.
* 그 배열 (혹은 복제본)의 참조를 신뢰할 수 없는 코드에 노출하지 않는다.
  * 제네릭 `varargs` 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다. (다른 메서드에 인수로 넘기기)
  * 예외 1) `@SafeVarargs`로 제대로 애노테이션된 또 다른 `varargs` 메서드에 넘기는 것은 안전하다.
  * 예외 2) 그저 배열 내용의 일부 함수를 호출만 하는 일반 메서드에 넘기는 것도 안전하다.

<br>

#### 예시
```java
// 자신의 제네릭 매겨변수 배열의 참조를 노출한다
static <T> T[] toArray(T... args) {
    return args;
}
```
* 반환하는 배열의 타입은 메서드에 인수를 넘기는 컴파일타임에 결정하는데, 그 시점에는 타입이 안전한지 확신하지 못한다.
* 그러므로 런타임때 `ClassCastException`이 발생할 가능성이 생긴다.
* 또한, 힙 오염이 발생하기도 한다.

<br>

## 핵심 정리
* 가변인수와 제네릭은 궁합이 좋지 않다.
  * 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고,
  * 배열과 제네릭의 타입 규칙은 서로 다르기 때문이다.
* 제네릭 `varargs` 매개변수는 타입 안전하지는 않지만, 허용된다.
  * 메서드에 제네릭 `varargs` 매개변수를 사용하고자 한다면, 먼저 그 메서드가 타입 안전한지 확인한 다음 `@SafeVarargs` 애너테이션을 달아 사용하는 데 불편함이 없게끔 해라.