> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 42. 익명 클래스보다는 람다를 사용하라

<br>

- [아이템 42. 익명 클래스보다는 람다를 사용하라](#아이템-42-익명-클래스보다는-람다를-사용하라)
  - [1 익명 클래스](#1-익명-클래스)
  - [2 람다](#2-람다)
    - [2-1 람다식](#2-1-람다식)
    - [2-2 비교자 생성 메서드](#2-2-비교자-생성-메서드)
  - [3 람다의 활용 - 함수 객체](#3-람다의-활용---함수-객체)
  - [4 람다 사용시 주의할 점](#4-람다-사용시-주의할-점)
    - [4-1 코드 줄 수가 많아지면 사용하지 마라](#4-1-코드-줄-수가-많아지면-사용하지-마라)
    - [4-2 람다가 모든 익명 클래스를 대체한 것은 아니다](#4-2-람다가-모든-익명-클래스를-대체한-것은-아니다)
    - [4-3 람다는 자신을 참조할 수 없다](#4-3-람다는-자신을-참조할-수-없다)
    - [4-4 직렬화를 극히 삼가야한다](#4-4-직렬화를-극히-삼가야한다)
  - [핵심 정리](#핵심-정리)

<br>

## 1 익명 클래스
* 람다 이전의 함수 타입 표현
  * 람다 이전에는 함수 타입을 표현하기 위해 추상 메서드를 하나만 담은 인터페이스를 사용했다.
  * **이런 인터페이스의 인스턴스를 함수 객체(function object)라고 하였고, 익명 클래스로 구현하였다.**

<br>

```java
// 익명 클래스의 인스턴스를 함수 객체로 사용 - 낡은 기법
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```
* 위와 같은 익명 클래스 방식은 코드가 너무 길기 때문에 **함수형 프로그래밍에는 적합하지 않다**.

<br>

## 2 람다

<br>

### 2-1 람다식
* 람다식
  * 자바 8부터 **추상 메서드 하나짜리 인터페이스**는 특별한 의미를 **함수형 인터페이스**라 부르기 시작하였다.
  * 그리고 **이 인터페이스의 인스턴스를 람다식(lambda expression)을 사용해 만들기 시작했다.**
* 람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다.
  * 컴파일러가 알아서 형변환등을 수행해준다.

<br>

```java
// 람다식을 함수 객체로 사용 - 익명 클래스 대체
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
* **컴파일러가 문맥을 살펴 타입을 추론해준다.**
  * 람다 : `Comparator<String>`
  * 매개변수(s1, s2) : `String`
  * 반환값 : `int`
* 상황에 따라 컴파일러가 타입을 결정하지 못하면 직접 명시해줘야 한다.
  * **타입 추론 규칙은 너무 복잡하기 때문에 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.**
  * 컴파일러가 "타입을 알 수 없다"는 오류를 낼 때만 해당 타입을 명시하면 된다.

<br>

### 2-2 비교자 생성 메서드
```java
Collections.sort(words, comparingInt(String::length));

words.sort(comparingInt(String::length));
```
* 람다 자리에 비교자 생성 메서드를 사용하면 코드를 더 간결하게 만들 수 있다.

<br>

## 3 람다의 활용 - 함수 객체
```java
// 상수별 클래스 몸체와 데이터를 사용한 열거 타입
public enum Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    };

    private final String symbol;

    Operation(String symbol) { this.symbol = symbol; }

    public abstract double apply(double x, double y);
}
```
```java
// 함수 객체(람다)를 인스턴스 필드에 저장해 상수별 동작을 구현한 열거 타입
public enum Operation {
    PLUS("+", (x, y) -> x + y),
    MINUS("-", (x, y) -> x - y);

    private final String symbole;
    private final DoubleBinaryOperator op;

    Operation(String symbol, DoubleBinaryOperator op) {
        this.symbol = symbol;
        this.op = op;
    }

    public double apply(double x, double y) {
        return op.applyAsDouble(x, y);
    }
}
```
* 람다를 이용하면 Enum의 인스턴스 필드를 이용하는 방식으로 상수별로 다르게 동작하는 코드를 쉽게 구현할 수 있다.
  * 가독성이 좋다.
* **생성자 안의 람다(`op`)는 컴파일 타임에 타입이 추론된다. 그러므로 인스턴스 멤버에 접근할 수 없다.**
  * **함수형 객체라 생각하면 당연한 얘기이다. (부수효과 방지)**

<br>

## 4 람다 사용시 주의할 점

<br>

### 4-1 코드 줄 수가 많아지면 사용하지 마라
* 람다는 이름이 없고 문서화도 못 한다.
  * **따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.**
* 한 줄일 때 가장 좋고 길어야 세 줄 안에 끝내는 게 좋다.

<br>

### 4-2 람다가 모든 익명 클래스를 대체한 것은 아니다
> 람다도 대체할 수 없는 곳이 있다
* **람다는 함수형 인터페이스에서만 쓰인다.**
  * **즉, 부수효과를 일으키지 않기 위해 매개변수만을 사용하여 구현을 해야한다.**
* 그러므로, **추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없다. 이럴땐 익명 클래스를 써야한다.**
  * 추상 클래스의 인스턴스는 인스턴스 멤버를 사용하기 때문에 부수효과를 발생시킬 수 있기 때문이다.

<br>

### 4-3 람다는 자신을 참조할 수 없다
* 람다는 자신을 참조할 수 없다.
  * **람다에서의 `this` 키워드는 바깥 인스턴스를 가리킨다.**
  * 반대로 익명 클래스에서의 `this`는 익명 클래스의 인스턴스 자신을 가리킨다.
* **함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야한다.**

<br>

### 4-4 직렬화를 극히 삼가야한다
* 람다도 익명 클래스처럼 직렬화 형태가 구현(가상머신별)별로 다를 수 있다.
* 따라서 람다를 직렬화하는 일은 극히 삼가야 한다.

<br>

## 핵심 정리
* **익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라.**
  * 함수형 인터페이스란 부수효과를 발생시키지 않는 인터페이스를 의미한다.
* 람다는 작은 함수 객체를 아주 쉽게 표현할 수 있어 함수형 프로그래밍에 굉장히 적절하다.