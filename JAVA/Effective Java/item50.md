> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 50. 적시에 방어적 복사본을 만들라

<br>

- [아이템 50. 적시에 방어적 복사본을 만들라](#아이템-50-적시에-방어적-복사본을-만들라)
  - [방어적으로 프로그래밍해야한다](#방어적으로-프로그래밍해야한다)
  - [방어적 복사를 안하면 발생하는 문제](#방어적-복사를-안하면-발생하는-문제)
  - [방어적 복사](#방어적-복사)
    - [생성자 방어적 복사](#생성자-방어적-복사)
    - [접근자 방어적 복사](#접근자-방어적-복사)
  - [방어적 복사가 불변만을 위한 것은 아니다](#방어적-복사가-불변만을-위한-것은-아니다)
  - [무조건 방어적 복사를 하라는 의미가 아니다](#무조건-방어적-복사를-하라는-의미가-아니다)
  - [핵심 정리](#핵심-정리)

<br>

## 방어적으로 프로그래밍해야한다
* 자바는 안전한 언어다. 하지만 완벽한 언어는 아니다. 
  * **하지만 아무리 자바라 해도 다른 클래스로부터의 침범을 아무런 노력없이 다 막을 수 없다.**
* **클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.**
* 어떤 경우든 적절치 않은 클라이언트로부터 클래스를 보호하는 데 충분한 시간을 투자하는 게 좋다.

<br>

## 방어적 복사를 안하면 발생하는 문제
```java
// 불변식을 지키지 못하는 클래스
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException();
        }
        this.start = start;
        this.end = end;
    }

    public Date start() {
        return start;
    }

    public Date end() {
        return end;
    }

    ...
}
```
```java
// Period 인스턴스의 내부를 공격해보자.
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 내부를 수정했다!
```
* **`Date`가 참조 값이기 때문에 주소 공유로 인한 불변식이 깨질 수 있다.**
  * 외부로부터 `Period`인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적 복사해야한다.

<br>

## 방어적 복사
**완전한 방어적 복사를 하기위해서는 객체를 생성하거나 반환하는 메서드를 방어적으로 복사해야한다.**

<br>

### 생성자 방어적 복사
```java
public Period(Date start, Date end) {
    this.start = new Date(start.getTime()); // 방어적 복사
    this.end = new Date(end.getTime());     // 방어적 복사

    if (this.start.compareTo(this.end) > 0) {
        throw new IllegalArgumentException();
    }
}
```
* **매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사한 점에 주목하자.**
  * 부자연스러워 보이지만 **반드시 이렇게 작성해야한다고한다.**
  * 그 이유는 멀티스레딩 환경이라면 **다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.**
  * 이를 검사시점/사용시점 공격이라고도 부리기도 한다.
* 생성자 방어적 복사에서는 `clone`을 사용하지 않는다.
  * `Date`가 `final`이 아니므로, `clone`이 `Date`가 정의한 게 아닐 수 있다.
  * **`clone`이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다.**
* **매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone`을 사용해서는 안 된다.**

<br>

### 접근자 방어적 복사
```java
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```
* 생성자와 접근자를 방어적 복사하면 완벽한 불변 객체를 만들 수 있다.

<br>

## 방어적 복사가 불변만을 위한 것은 아니다
* 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는 지를 생각해야 한다.
  * **외부에서 변경되도 그 클래스가 문제없이 동작할지는 모른다면 방어적 복사를 해야한다.**
* **ex. 클라이언트가 건네준 객체를 `Set`이나 `Map`에 저장하면, 추후 그 객체가 변경될 경우 `Set`과 `Map`에 저장된 객체도 같이 변경된다.**

<br>

## 무조건 방어적 복사를 하라는 의미가 아니다
* 방어적 복사에는 성능 저하가 따른다.
* 그러므로, 다음과 같은 상황에선 방어적 복사를 생략할 수 있다.
  * **복사 비용이 너무 큰 경우**
  * **호출자가 컴포넌트 내부를 수정하지 않으리라는 확신이 있다면**
    * 이러한 경우 문서화를 명확히 하자.

<br>

## 핵심 정리
* **클래스가 클라이언트로부터 받는 혹은 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.**
* **복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 생략해도 된다.**
  * 대신 문서에 명시하도록 하자.
