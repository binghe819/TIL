> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.



# 아이템 8. finalizer와 cleaner 사용을 피하라

- [아이템 8. finalizer와 cleaner 사용을 피하라](#아이템-8-finalizer와-cleaner-사용을-피하라)
  - [finalizer와 cleaner란?](#finalizer와-cleaner란)
    - [finalizer](#finalizer)
  - [finalizer와 cleaner의 단점](#finalizer와-cleaner의-단점)
    - [단점 1 - 언제 실행될지 알 수 없다](#단점-1---언제-실행될지-알-수-없다)
    - [단점 2 - 인스턴스 반납을 지연시킬 수 있다](#단점-2---인스턴스-반납을-지연시킬-수-있다)
    - [단점 3 - 아예 실행되지 않을 수도 있다](#단점-3---아예-실행되지-않을-수도-있다)
    - [단점 4 - 성능 문제도 있다](#단점-4---성능-문제도-있다)
    - [단점 5 - 보안 이슈](#단점-5---보안-이슈)
  - [자원 반납 하는 방법](#자원-반납-하는-방법)

## finalizer와 cleaner란?

<br>

### finalizer

```java
public class Object {
    ...
      
    @Deprecated(since="9")
    protected void finalize() throws Throwable() {}
}
```

* fianlizer란?
  * **finalize는 객체가 소멸될 때 호출되기로 약속된 메서드이다.** 객체 소멸자라고 불리운다.
  * 메모리 누수를 방지하기 위해 JVM이 실행하는 GC가 수행될 때 더 이상 사용하지 않는 자원에 대한 정리 작업을 진행하기 위해 호출되는 종료자 메서드라고 한다.
* 누가 호출하는가?
  * **JVM**이 그 객체가 가지고 있는 메모리가 반환되기 전에 이것을 수행한다. (GC)

<br>

## finalizer와 cleaner의 단점

**Finalizer는 예측 불가능하고, 위험하며, 대부분 불필요하다.** 그걸 쓰면 이상하게 동작하기도 하고, 성능도 안좋아지고, 이식성에도 문제가 생길 수 있다. 

딱 두가지 경우일 경우만 유용하게 쓰인다. 이 외에는 극히 드물다.

* 안전망 역할로 자원을 반납하고자 하는 경우
* 네이티브 리소스를 정리해야 하는 경우

<br>

자바 9에서는 Finalizer가 deprecated 됐으며 `Cleaner`라는게 새로 생겨서 Finalizer보다 덜 위험하지만 (별도의 스레드를 사용하기 때문에), 여전히 예측 불가능하며, 느리고, 일반적으로 불필요하다.

<br>

### 단점 1 - 언제 실행될지 알 수 없다

언제 실행될지 알 수 없다. **어떤 객체가 더이상 필요 없어진 시점에 그 즉시 finalizer 또는 cleaner가 바로 실행되지 않을 수 있다.** 그 사이에 시간이 얼마나 걸릴지는 아무도 모른다. **따라서 타이밍이 중요한 작업을 절대로 finalizer나 cleaner에서 하면 안된다.** 예를 들어, 파일 리소스를 반납하는 작업을 그 안에서 처리한다면, 실제로 그 파일 리소스 처리가 언제 될지 알 수 없고, 자원 반납이 안되서 더이상 새로운 파일을 열 수 없는 상황이 발생할 수도 있다.

<br>

### 단점 2 - 인스턴스 반납을 지연시킬 수 있다

특히 Finalizer는 인스턴스 반납을 지연 시킬 수도 있다. **Finalizer 스레드는 우선 순위가 낮아서 언제 실행될지 모른다.** 따라서, Finalizer 안에 어떤 작업이 있고, 그 작업을 스레드가 처리 못해서 대기하고 있다면, 해당 인스턴스는 GC가 되지 않고 계속 쌓이다가 결국엔 `OutOfMemoryException`이 발생할 수도 있다.

Cleaner는 별도의 스레드로 동작하니까 이 부분에 있어서 조금은 나을 수도 있지만, 여전히 해당 스레드는 백그라운에서 동작하고 언제 처리될지는 알 수 없다.

<br>

### 단점 3 - 아예 실행되지 않을 수도 있다

Finalizer나 Cleaner는 아예 실행되지 않을 수도 있다. 따라서, **Finalizer나 Cleaner로 저장소 상태를 변경하는 일을 하지 말아야 한다.**

`System.gc`나 `System.runFinalization`에 속지 말라. 그걸 실행해도 Finalizer나 Cleaner를 바로 실행한다고 보장하진 못한다. 그걸 보장해주겠다고 만든 `System.runFinalizersOnExit`와 그 쌍둥이 `Runtime.runFinalizersOnExit`은 둘 다 망했고 수십년간 deprecated 상태다.

<br>

### 단점 4 - 성능 문제도 있다

심각한 성능 문제도 있다. `AutoCloseable`객체를 만들고, `try-with-resource`로 반납을 하는데 걸리는 시간은 12ns인데 반해, Finalizer를 사용한 경우에 550ns가 걸렸다.. 그냥 쓰지 말아라

<br>

### 단점 5 - 보안 이슈

Finalizer 공격이라는 심각한 보안 이슈에도 이용될 수 있다. 어떤 클래스가 있고 그 클래스를 공격하려는 클래스가 해당 클래스를 상속 받는다. 그리고 그 나쁜 클래스의 인스턴스를 생성하는 도중에 예외가 발생하거나, 직렬화 할 때 예외가 발생하면, 원래는 죽었어야 할 객체의 finalizer가 실행될 수 있다. 그럼 그 안에서 해당 인스턴스의 객체를 기록할 수도 있고, GC가 되지 못하게 할 수도 있다. 또한 그 안에서 인스턴스가 가진 메서드를 호출할 수도 있다..

원래는 생성자에서 예외가 발생해서 존재하질 않았어야 하는 인스턴스인데, Finalizer 때문에 살아 남아 있는 것이다.

<br>

## 자원 반납 하는 방법



































