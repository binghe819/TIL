> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.



# 아이템 8. finalizer와 cleaner 사용을 피하라

- [아이템 8. finalizer와 cleaner 사용을 피하라](#아이템-8-finalizer와-cleaner-사용을-피하라)
  - [finalizer와 cleaner란?](#finalizer와-cleaner란)
    - [finalizer](#finalizer)
  - [finalizer와 cleaner의 단점](#finalizer와-cleaner의-단점)
    - [단점 1 - 언제 실행될지 알 수 없다](#단점-1---언제-실행될지-알-수-없다)
    - [단점 2 - 인스턴스 반납을 지연시킬 수 있다](#단점-2---인스턴스-반납을-지연시킬-수-있다)
    - [단점 3 - 아예 실행되지 않을 수도 있다](#단점-3---아예-실행되지-않을-수도-있다)
    - [단점 4 - 성능 문제도 있다](#단점-4---성능-문제도-있다)
    - [단점 5 - 보안 이슈](#단점-5---보안-이슈)
  - [올바른 자원 반납 하는 방법 - AutoCloseable](#올바른-자원-반납-하는-방법---autocloseable)
  - [그럼 finalizer나 cleaner는 언제 사용하는건가?](#그럼-finalizer나-cleaner는-언제-사용하는건가)

## finalizer와 cleaner란?

<br>

### finalizer

```java
public class Object {
    ...
      
    @Deprecated(since="9")
    protected void finalize() throws Throwable() {}
}
```

* finalizer란?
  * **finalize는 객체가 소멸될 때 호출되기로 약속된 메서드이다.** 객체 소멸자라고 불리운다.
  * 메모리 누수를 방지하기 위해 **JVM이 실행하는 GC가 수행될 때 더 이상 사용하지 않는 자원에 대한 정리 작업을 진행하기 위해 호출되는 종료자 메서드이다.**
* 누가 호출하는가?
  * **JVM**이 그 객체가 가지고 있는 메모리가 반환되기 전에 이것을 수행한다. (GC)

> C++의 소멸자처럼 `finalizer()` 메서드를 사용하는 경우가있는데, C++와는 전혀 다르기에 오해하지말자.

<br>

## finalizer와 cleaner의 단점

**Finalizer는 예측 불가능하고, 위험하며, 대부분 불필요하다.** 그걸 쓰면 이상하게 동작하기도 하고, 성능도 안좋아지고, 이식성에도 문제가 생길 수 있다. 

딱 두가지 경우일 경우만 유용하게 쓰인다. 이 외에는 극히 드물다.

* 안전망 역할로 자원을 반납하고자 하는 경우
* 네이티브 리소스를 정리해야 하는 경우

<br>

자바 9에서는 Finalizer가 deprecated 됐으며 `Cleaner`라는게 새로 생겨서 Finalizer보다 덜 위험하지만 (별도의 스레드를 사용하기 때문에), 여전히 예측 불가능하며, 느리고, 일반적으로 불필요하다.

<br>

### 단점 1 - 언제 실행될지 알 수 없다

언제 실행될지 알 수 없다. **어떤 객체가 더이상 필요 없어진 시점에 그 즉시 finalizer 또는 cleaner가 바로 실행되지 않을 수 있다.** 그 사이에 시간이 얼마나 걸릴지는 아무도 모른다. **따라서 타이밍이 중요한 작업을 절대로 finalizer나 cleaner에서 하면 안된다.** 예를 들어, 파일 리소스를 반납하는 작업을 그 안에서 처리한다면, 실제로 그 파일 리소스 처리가 언제 될지 알 수 없고, 자원 반납이 안되서 더이상 새로운 파일을 열 수 없는 상황이 발생할 수도 있다.

<br>

### 단점 2 - 인스턴스 반납을 지연시킬 수 있다

특히 Finalizer는 인스턴스 반납을 지연 시킬 수도 있다. **Finalizer 스레드는 우선 순위가 낮아서 언제 실행될지 모른다.** 따라서, Finalizer 안에 어떤 작업이 있고, 그 작업을 스레드가 처리 못해서 대기하고 있다면, 해당 인스턴스는 GC가 되지 않고 계속 쌓이다가 결국엔 `OutOfMemoryException`이 발생할 수도 있다.

Cleaner는 별도의 스레드로 동작하니까 이 부분에 있어서 조금은 나을 수도 있지만, 여전히 해당 스레드는 백그라운에서 동작하고 언제 처리될지는 알 수 없다.

<br>

### 단점 3 - 아예 실행되지 않을 수도 있다

Finalizer나 Cleaner는 아예 실행되지 않을 수도 있다. 즉, **수행 여부조차 보장하지 않는다.**

따라서, **Finalizer나 Cleaner로 저장소 상태를 변경하는 일을 하지 말아야 한다.**

**예를 들어 DB 같은 공유 자원의 Lock 해제를 finalizer나 cleaner에 맡겨 놓으면 DB에 Lock을 계속 해제하지못해 분산 시스템 전체가 서서히 멈출 것이다.**

`System.gc`나 `System.runFinalization`에 속지 말라. 그걸 실행해도 Finalizer나 Cleaner를 바로 실행한다고 보장하진 못한다. 그걸 보장해주겠다고 만든 `System.runFinalizersOnExit`와 그 쌍둥이 `Runtime.runFinalizersOnExit`은 둘 다 망했고 수십년간 deprecated 상태다.

<br>

### 단점 4 - 성능 문제도 있다
조슈아 블로크는 `AutoCloseable`로 만든 객체가 `try-with-resource`로 반납하는데 걸리는 시간이 12ns이 걸리고, Finalizer를 사용한 경우 550ns가 걸렸다고한다.

`try-with-resource` 방식은 객체 자신이 리소스를 닫도록했지만, finalizer는 GC의 수거를 기다린게 차이를 불러일으켰다.

게다가 finalizer가 GC의 효율을 떨어뜨린다고한다.

> cleaner도 직접 사용하면 finalizer와 유사한 성능을 보인다. 다만, 안정망 형태로 사용하면 훨씬 빠르긴한다.

<br>

### 단점 5 - 보안 이슈

Finalizer 공격이라는 심각한 보안 이슈에도 이용될 수 있다. 어떤 클래스가 있고 그 클래스를 공격하려는 클래스가 해당 클래스를 상속 받는다. 

그리고 그 나쁜 클래스의 인스턴스를 생성하는 도중에 예외가 발생하거나, 직렬화 할 때 예외가 발생하면, 원래는 죽었어야 할 객체의 finalizer가 실행될 수 있다. 

그럼 그 안에서 해당 인스턴스의 객체를 기록할 수도 있고, GC가 되지 못하게 할 수도 있다. 또한 그 안에서 인스턴스가 가진 메서드를 호출할 수도 있다..

원래는 생성자에서 예외가 발생해서 존재하질 않았어야 하는 인스턴스인데, Finalizer 때문에 살아 남아 있는 것이다.

> final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 `finalize` 메서드를 만들고 final로 선언하자.

<br>

## 올바른 자원 반납 하는 방법 - AutoCloseable

**가장 올바른 자원을 반납하는 방안은 `AutoCloseable`을 구현하고, `try-with-resource`를 사용하는 것이다.**

그리고 각 인스턴스는 자신이 닫혔는지 추적하는 것이 좋다.

즉, `close`메서드에서 이 객체는 더 이상 유효하지 않음을 필드에 기록하고, 다른 메서드는 이 필드를 검사해서 객체가 닫힌 후에 호출시 `IllegalStateException`을 던지게하는 것이다.

<br>

## 그럼 finalizer나 cleaner는 언제 사용하는건가?

1. **안전망**
   * `close()` 메서드를 호출하지않아 자원이 반납되지않는 상황을 방지하기 위함. (사실상 `close()`를 잘 호출하면 큰 문제없다.)
   * `FileInputStream`, `FileOutputStream`, `ThreadPoolExcutor` 모두 안전망으로 활용하고있다.
2. **네이티브 피어와 연결된 객체**
   * 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다.
   * **네이티브 피어는 자바 객체가 아니라서 GC의 대상이되지않는다. 그러므로 `finalizer`나 `cleaner`로 명시적으로 GC에의해 수거되도록 설정하는 것이다.**
   * **물론 성능 저하를 감당할 수 있고, 네이티브 피어가 심각한 자원을 가지고있지않을때만 활용하는 것이 좋다.**


