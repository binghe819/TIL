> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

- [아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라](#아이템-21-인터페이스는-구현하는-쪽을-생각해-설계하라)
  - [불변식을 해치지 않는 디폴트 메서드를 작성하기 어렵다](#불변식을-해치지-않는-디폴트-메서드를-작성하기-어렵다)
    - [예시](#예시)
  - [꼭 필요한 경우가 아니면 디폴트 메서드를 추가하는 것을 피하자](#꼭-필요한-경우가-아니면-디폴트-메서드를-추가하는-것을-피하자)

<br>

## 불변식을 해치지 않는 디폴트 메서드를 작성하기 어렵다
자바 8 전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 메서드를 추가할 방법이 없었다.

자바 8부터 디폴트 메서드가 생기면서 기존 구현체를 깨뜨리지 않고 메서드를 추가할 수 있게 되었다.

하지만, **생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.**

<br>

### 예시
자바 8의 `Collection` 인터페이스에는 많은 디폴트 메서드가 추가되었다.

가장 대표적인 것이 `removeIf()`메서드이며, `Predicate`의 결과에 따라 원소를 제거하는 함수이다.

**디폴트 메서드는 범용적으로 구현되어 있지만 모든 `Collection` 구현체와 어울리지는 않는다. `removeIf()`에도 어울리지 않는다.**

다음 Apache에서 릴리즈한 `SynchronizedCollection` 예제를 보자.

<p align="center"><img src="./image/스크린샷 2021-01-05 오후 3.41.15-side.png" width = "700"></p>

**4.4 이전 버전까지는 `removeIf()`가 동기적으로 구현 되어있지않아 디폴트 메서드를 부르게 되어 동기적으로 작동하지 않는 문제가 발생하게 된다.**

물론 컴파일 에러는 발생하지 않지만 `ConcurrentModificationException`과 같은 런타임 에러를 발생시킨다.

**이 문제때문에 4.4버전부터는 동기적으로 오버라이딩된 것을 볼 수 있다.**

이것 외의 `java.util`의 `SynchronizedCollection`에도 모든 디폴트 메서드가 오버라이딩 된 것을 볼 수 있다.

<p align="center"><img src = "./image/스크린샷 2021-01-05 오후 4.04.38.png" width = "700"></p>

<br>

## 꼭 필요한 경우가 아니면 디폴트 메서드를 추가하는 것을 피하자
디폴트 메서드를 추가하는 순간 기존 클라이언트의 코드가 제대로 동작하지 않을 가능성이 크다.

따라서, 인터페이스를 설계할 때는 세심히 주의를 기울여야 한다.

이를 검증하기 위해 서로 다른 방식으로 최소 세 가지의 구현체를 만들어보라.

인터페이스를 릴리즈한 후라도 결함을 수정하는 게 가능한 경우가 있지만, 절대 그 가능성을 기대하면 안된다.