> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

<br>

<br>

## 기본 타입과 박싱된 기본 타입의 차이점
1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 갖는다.
   * 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별할 수 있다. (객체이므로)
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 `null`을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

<br>

## 기본 타입과 박싱된 기본 타입은 주의해서 사용해야 한다

<br>

### 동일성 문제
```java
Comparator<Integer> naturalOrder = 
    (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);

int result = naturalOrder.compare(new Integer(42), new Integer(42));
System.out.println(result); // 1
```
* 위 코드에서 결과가 0이 나와야 정상이지만, 1이 나온다.
  * 그 이유는 `==` 비교가 객체라서 동일성 비교가 되어 false가 나오기 때문이다.
* 이 문제를 해결하기 위해선 언박싱하거나, `equals`로 문제를 해결해야한다.

<br>

### null 문제
```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42) {  // i가 null이면 NPE발생
            System.out.println("믿을 수 없군!");
        }
    }
}
```
* 기본 타입의 값은 언제나 유효한 값이 들어간다.
* 하지만 박싱된 기본 타입은 참조 타입이기 때문에 `null`이 올 수 있게 된다.

<br>

### 성능 저하
```java
public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```
* 위 코드는 `sum`을 계산할 때 계속해서 박싱과 언방식이 자동적으로 일어나서 성능이 느려진다.
  * 객체를 생성했다가, 풀었다가를 반복하기 때문에

<br>

## 박싱된 값은 언제 써야하는가?
1. 컬렉션의 원소, 키, 값으로 사용된다.
   * 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다.
2. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

<br>

## 핵심 정리
* **기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능한 기본 타입을 사용하라.**
  * 기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야 한다면 주의를 기울이자.
* 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
  * 동일성 문제 (`==`)
  * null 문제
  * 쓸데 없는 기본 타입을 오토 박싱하는데서 발생하는 성능 저하
