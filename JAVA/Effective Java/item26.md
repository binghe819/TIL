> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 26. 로 타입은 사용하지 말라

- [아이템 26. 로 타입은 사용하지 말라](#아이템-26-로-타입은-사용하지-말라)
  - [로타입(Raw Type)이란?](#로타입raw-type이란)
  - [로타입의 문제 - 타입 안정성](#로타입의-문제---타입-안정성)
  - [로타입은 그럼 왜 그대로 두는가?](#로타입은-그럼-왜-그대로-두는가)
  - [로타입을 써야할 때도 있다](#로타입을-써야할-때도-있다)
    - [class 리터럴](#class-리터럴)
    - [instanceof](#instanceof)
  - [핵심 정리](#핵심-정리)

<br>

## 로타입(Raw Type)이란?
**제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의된다.**
* 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
  * `List<E>`의 로타입은 `List`이다.
* **로타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작한다.**
  * 이는 제네릭이 도입하기 전의 코드와 호환하기 위해서이다.

<br>

## 로타입의 문제 - 타입 안정성

```java
// 로타입 선언 (elements가 Object로 생성됨)
List stamps = new ArrayList();

// 실수로 coin을 넣는다.
stamps.add(new Coin()); // "unchecked call" 경로를 내뱉지만 실행은 된다.

// 로타입의 반복자 - 문제 발생
for (Iterator i = stamps.iterator(); i.hasNext();) {
    Stamp stamp = (Stamp)i.next(); // ClassCaseException을 던진다.
    // ...
}
```
* 위와 같이 로타입은 `stamp`만 담고자하는 리스트에 `coin`을 담아도 컴파일타임때 에러가 안난다.
* 오류가 발생하고 한참 뒤인 런타임에야 알아챌 수 있다.
> **위와 같은 문제로 로타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 잃게 된다. 사용하지 말자.**

<br>
메서드를 사용할 때도 주의가 필요하다.

**매개변수로 모르는 타입의 원소도 받는 로타입을 사용하면 안된다.**

```java
// 잘못된 사용방법
public static void main(String[] args) {
    List<String> strings = new ArrayList<>();
    unsafeAdd(strings, Integer.valueOf(45)); // list가 String인지 모르고 add하게 된다.

    String s = strings.get(0); // ClassCaseException (String으로 자동 형변환을 시도하다가 예외 발생)
}

private static void unsafeAdd(List list, Object data) { // 로타입의 안 좋은 예시
    list.add(data);
}
```
* **메서드를 사용할 때는 제네릭 메서드나 와일드 카드를 사용해서 데이터 타입을 명시해줘야 한다.**

<br>

## 로타입은 그럼 왜 그대로 두는가?
절대 써서는 안 되는 로타입을 애초에 왜 만들어놓은 것일까??
* 바로 호환성 때문이다.
  * 제네릭이 도입되기 전 10년의 기존 코드를 모두 호환하기위해서 그대로 두는 것.
  * **이와 같이 마이그레이션 호환성을 위해 로타입을 지원하고 제네릭 구현에는 소거([아이템 28](./item28.md))방식을 사용하기로 했다.**

<br>

## 로타입을 써야할 때도 있다
로타입은 나쁘지만, 다음과 같은 경우엔 써야한다.

<br>

### class 리터럴
* `List.class`, `String[].class`, `int.class`는 허용된다. (로타입)
* `List<String>.class`, `List<?>.class`는 허용되지 않는다. (제네릭)

<br>

### instanceof
```java
if (o instanceof Set) { // 로타입 (Set타입임을 확인하고 형변환한다.)
    Set<?> s = (Set<?>) o; // 와일드카드 타입 (형변환)
}
```
* 런타임에는 제네릭 타입정보가 지워지므로 `instanceof`연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.

<br>

## 핵심 정리
* 로타입은 타입 안정성이 불안하여 런타임때 예외가 발생할 수 있기때문에 사용하면 안된다.
* 로타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.
* 로타입의 문제를 해결하는 방법 제네릭을 사용하는 것이다.
  * `Set<Object>`는 어떤 타입의 객체도 저장할 수 있는 **매개변수화 타입**이고
  * `Set<?>`은 모종의 타입 객체만 저장할 수 있는 **와일드카드 타입**이다.
    * `Set<?>`은 null 외에는 어떤 원소도 넣을 수 없다.  (사용하고 싶다면 `Set<? extends ...>`처럼 사용한다.)