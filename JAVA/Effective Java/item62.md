> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라

<br>

- [아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라](#아이템-62-다른-타입이-적절하다면-문자열-사용을-피하라)
  - [문자열을 사용하지 않아야 할 사례](#문자열을-사용하지-않아야-할-사례)
    - [문자열이 다른 값 타입을 대신하는 사례](#문자열이-다른-값-타입을-대신하는-사례)
    - [문자열이 열거 타입을 대신하는 사례](#문자열이-열거-타입을-대신하는-사례)
    - [문자열은 혼합 타입을 대신하는 사례](#문자열은-혼합-타입을-대신하는-사례)
  - [문자열은 권한을 표현하기에 적합하지 않다](#문자열은-권한을-표현하기에-적합하지-않다)
  - [핵심 정리](#핵심-정리)

<br>

## 문자열을 사용하지 않아야 할 사례

<br>

### 문자열이 다른 값 타입을 대신하는 사례
파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 사용한다.

하지만, 입력받을 데이터가 진짜 문자열일 경우에만 문자열을 사용하라

* 데이터가 수치형이라면 -> `int`, `float`, `BigInteger`
* 예/아니오 질문이라면 -> 열거타입이나 `boolean`

즉, 기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하라

<br>

### 문자열이 열거 타입을 대신하는 사례
문자열은 열거 타입을 대신하기에 적합하지 않다.

문자열보단 열거 타입을 사용하라

<br>

### 문자열은 혼합 타입을 대신하는 사례
```java
String compoundKey = className + "#" + i.next();
```
`#`를 사용해서 두 요소를 분리하는 문자열이다.

하지만 만약 요소에 `#`이 있다면 이는 오류가 발생한다.

게다가 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 크다.

차라리 private 정적 멤버 클래스를 만들어서 사용하라.

<br>

## 문자열은 권한을 표현하기에 적합하지 않다
```java
// 잘못된 예 - 문자열을 사용해 권한을 구분하였다
public class ThreadLocal {
    private ThreadLocal() {} // 객체 생성 불가

    // 현 스레드의 값을 키로 구분해 저장한다.
    public static void set(String key, Object value);

    // (키가 가리키는) 현 스레드의 값을 반환한다.
    public static Object get(String key);
}
```
위 방식의 문제
* 스레드 구분용 문자열 키가 전역 이름공간에서 공유된다
* 클라이언트가 의도치않게 키를 잘못넣으면 변수를 공유하게 된다 (보안이 약하다)

<br>

```java
public class ThreadLocal {
    private ThreadLocal() {}

    public static class Key {
        Key() {}
    }

    // 위조 불가능한 고유 키를 생성
    public static Key getKey() {
        return new Key();
    }

    // set, get
}
```
위 코드를 더 리팩토링해보면 다음과 같이 된다
```java
public final class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
}
```

<br>

## 핵심 정리
* 더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 싶은 유혹을 뿌리쳐라.
* 문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성이 크다.
* 문자열을 잘못 하용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.


