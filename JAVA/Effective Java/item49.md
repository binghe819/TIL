> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 49. 매개변수가 유효한지 검사하라

<br>

- [아이템 49. 매개변수가 유효한지 검사하라](#아이템-49-매개변수가-유효한지-검사하라)
  - [오류는 가능한 빨리 잡아야한다](#오류는-가능한-빨리-잡아야한다)
  - [매개변수 검사를 하지 않으면](#매개변수-검사를-하지-않으면)
  - [문서화해야 한다](#문서화해야-한다)
  - [유용한 유효성 검사 도구들](#유용한-유효성-검사-도구들)
    - [null 관련 검사](#null-관련-검사)
    - [리스트와 배열 전용 검사](#리스트와-배열-전용-검사)
    - [asser`](#asser)
  - [매개변수는 메서드 코드 시작부분에서 검사하자](#매개변수는-메서드-코드-시작부분에서-검사하자)
  - [유효성 검사가 필요 없는 경우도 있다](#유효성-검사가-필요-없는-경우도-있다)
  - [핵심 정리](#핵심-정리)

<br>

## 오류는 가능한 빨리 잡아야한다
* 메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다.
  * 예컨대 인덱스 값은 음수이면 안 되며, 객체 참조는 `null`이 아니어야하는 식이다.
* **이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야한다.**
  * **오류는 가능한 빨리 잡아야한다.**

<br>

## 매개변수 검사를 하지 않으면
* 매개변수 검사를 하지 않으면 다음 문제가 생긴다.
  * 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
  * 메서드가 잘 수행되지만 잘못된 결과를 반환할 수도 있다.
  * 어떤 객체를 이상한 상태로 만들어놓아서 알 수 없는 시점에 메서드와는 관련 없는 오류를 낼 수도 있다.
* 즉, 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있다.

<br>

## 문서화해야 한다
```java
/**
 * (현재 값 mod m) 값을 반환한다. 이 메서드는 
 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
 *
 * @param m 계수(양수여야 한다.)
 * @return 현재 값 mod m
 * @throws ArithmeticException m이 0보다 작거라 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0) {
        throw new ArithmeticException("계수(m)은 양수여야 합니다." + m);
    }
    // 계산 수행
}
```
* `public`, `protected` 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.
* 클래스 수준 주석은 그 클래스의 모든 `public` 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.
  * 위 코드에서도 `BigInteger`가 `null`을 받으면 `NullPointException`을 던지게 된다.

<br>

## 유용한 유효성 검사 도구들

<br>

### null 관련 검사
* 자바 7에 추가된 `java.util.Objects.requireNonNull`
  * `this.strategy = Objects.requireNonNull(strategy, "전략");`
* `@Nullable`

<br>

### 리스트와 배열 전용 검사
* 자바 9에 추가된 `checkFromIndexSize`, `checkFromToIndex`, `checkIndex`
  * 닫힌 범위(양 끝단 값을 포함하는)는 다루지 못한다.

<br>

### asser`
* `public`이 아닌 메서드라면 단언문(`assert`)을 사용해 매개변수 유효성을 검증할 수 있다.
  ```java
  private static void sort(long a[], int offset, int length) {
      assert a != null;
      assert offset >= 0 && offset <= a.length;
      assert length >= 0 && length <= a.length - offset;
      // 계산 수행
  }
  ```
* 핵심은 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다.
* 단언문은 일반적인 유효성 검사와 다르다.
  * 실패하면 `AssertionError`를 던진다.
  * 런타임에 아무런 효과도, 아무런 성능 저하도 없다. (단, java 실행시 -ea를 설정하면 런타임에 영향을 준다.)

<br>

## 매개변수는 메서드 코드 시작부분에서 검사하자
```java
static List<Integer> intArrayAsList(int[] a) {
    Objects.requireNonNull(a);

    return new AbstractList<>() {
        // ... a를 많이 매우 많이 사용하게 됨.
    }
}
```
* **메서드 초반에 `requireNonNull`을 통해 `null` 검사를 하지 않았다면 새로 생성한 `List`를 반환하고, 돌려받은 클라이언트가 `List`를 사용하려할 때 비로소 예외가 발생한다.**

<br>

## 유효성 검사가 필요 없는 경우도 있다
* **유효성을 검사하는 비용이 지나치게 큰 경우 또는 계산 과정에서 암묵적으로 유효성 검사가 진행될 때이다.**
* 예를 들어 `Collections.sort(List)`처럼 리스트를 정렬할 때는 정렬 과정에서 모든 객체가 상호 비교된다. 만일 비교할 수 없는 타입의 객체가 있으면 `ClassCastException`이 발생할 것이기 때문에 비교하기에 앞서 모든 원소를 검증하는 것은 불필요한 과정이 된다.

<br>

## 핵심 정리
* **이번 아이템을 "매개변수에 제약을 두는 게 좋다"로 해석하면 안된다.**
  * 사실은 그 반대다. 메서드는 최대한 범용적으로 설계해야 한다.
* 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다.
  * 그 제약들은 문서화하고 메서드 시박 부분에서 명시적으로 검사해야 한다.