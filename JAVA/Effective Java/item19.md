> 본 자료는 [Effective Java 3/E]()를 바탕으로 작성되었습니다.

# 아이템 19. 상속을 고려해 설계하고 문서화하라. 아니면 상속을 금지하라

- [상속을 고려한 설계와 문서화란?](#상속을-고려한-설계와-문서화란)
- [직접 하위 클래스를 만들어 테스트해야한다](#직접-하위-클래스를-만들어-테스트해야한다)
- [상속용 클래스의 생성자는 재정의 가능 메서드를 호출하면 안된다](#상속용-클래스의-생성자는-재정의-가능-메서드를-호출하면-안된다)
- [Cloneable과 Serializable도 주의해야 한다](#cloneable과-serializable도-주의해야-한다)
- [일반 구체 클래스는 상속용으로 사용해도 되는가?](#일반-구체-클래스는-상속용으로-사용해도-되는가)
- [핵심 정리](#핵심-정리)

<br>

## 상속을 고려한 설계와 문서화란?

* **메서드를 재정의하면 어떤 일이 일어나는지** 정확히 정리하여 문서로 남겨야한다.

* 상속용 클래스는 **재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.**
  * 클래스의 공개 API 메서드에서 자신의 또 다른 메서드를 호출할 수 있다. 이때, 호출하는 메서드가 재정의 가능한 메서드라면 그 메서드를 호출한다고 공개 API 메서드에 설명해줘야한다.

```java
public class example {
  
  // callPrivateMethod()를 호출한다고 명시해줘야 한다.
  public void publicApiMethod() {
    callPrivateMethod();
  }
  
  // 하위 클래스에서 재정의가 가능하다.
  protected void callPrivateMethod() {
    ...
  }
  
}
```

* 좋은 API 문서는 '어떻게'가 아닌 '무엇'을 설명해야한다.
* 하지만, 클래스를 안전하게 상속할 수 있또록 하려면 내부 구현이 '어떻게'되는지 설명해야한다.



>  **재정의함으로써 영향을 받는 메서드나 주는 메서드 모두 문서화를 하자.**

<br>

## 직접 하위 클래스를 만들어 테스트해야한다

> 널리 쓰일 클래스를 상속용으로 설계한다면 문서화한 내부 사용 패턴과, 
>
> protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을 잘 인식해야 한다.
>
> 그러므로 테스트를 꼭 해줘야 한다.

* 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다
  * 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

<br>

## 상속용 클래스의 생성자는 재정의 가능 메서드를 호출하면 안된다

> **상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행된다.**

* 상속용 클래스의 생성자는 직접적이든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
  * **상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.**

```java
public class Super {
  // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
  public Super() {
    overrideMe();
  }
  
  public void overrideMe(){
  }
}
```

```java
public final class Sub extends Super {
  // 초기화되지 않은 final 필드. 생성자에서 초기화한다.
  private final Instant instant;
  
  Sub() {
    instant = Instant.now();
  }
  
  // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
  @Override
  public void overrideMe() {
    System.out.println(instant);
  }
  
  public static void main(String[] args) {
    Sub sub = new Sub(); // null (문제)
    sub.overrideMe(); // overrideMe
  }
}
```

* instant를 두번 출력하리라 기대하지만, 첫 번째가 null을 출력한다.
  * **상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideMe를 호출하기 때문이다.**

<br>

## Cloneable과 Serializable도 주의해야 한다

> **생성자와 비슷한 효과를 내는 모든 메서드는 재정의 가능 메서드를 호출하면 안된다. **

* **clone과 readObject 메서드는 생성자와 비슷한 효과를 낸다. (새로운 객체를 만든다)**
  * 따라서 둘을 구현해야 한다면, 이들이 받는 제약도 생성자와 비슷하다.
* **즉, clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.**
  * readObject - 하위 클래스의 상태가 미처 다 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다.
  * clone - 하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출하게 된다.

<br>

## 일반 구체 클래스는 상속용으로 사용해도 되는가?

> 추상 클래스가 아닌 일반 구체 클래스를 상속용으로 사용해도 되는가?

* **상속은 하위 클래스가 상위 클래스에 강하게 의존하는 형식이다.**
  * 그러므로, 일반 구체 클래스(상위 클래스)에 변화가 생길 때마다 하위 클래스를 오동작하게 만드는 원인이 된다.
* **가장 좋은 방법은 상속용으로 설계하지 않는 클래스는 상속을 금지하는 것이다.**
  * 상속을 금지하는 방법은 두 가지이다.
    * 클래스를 final로 선언 - `public final class example`
    * 모든 생성자를 private이나 default로 - `private example() {}`

> 물론 **일반 구체 클래스를 상속해야하는 경우가 발생한다.**
>
> 이럴땐, **클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기면 된다.**
>
> **하위 클래스에서 재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽히 제거하라는 말이다.**

<br>

## 핵심 정리

* 상속용 클래스를 설계하기란 결코 만만치 않다.
  * 상속은 기본적으로 하위 클래스가 상위 클래스에 굉장히 의존적이다. (의존성으로 인한 문제)
  * 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행된다. (하위 클래스의 멤버가 초기화 되기전에 사용되는 문제)
* 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.